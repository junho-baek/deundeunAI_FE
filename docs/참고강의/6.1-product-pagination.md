# 6.1 Product Pagination

## 커밋 개요

이 커밋은 Supabase의 `range()` 메서드를 사용하여 페이지네이션을 구현합니다. Zod를 사용한 쿼리 파라미터 검증, 총 페이지 수 계산, 그리고 `preventScrollReset`을 통한 스크롤 위치 유지까지 포함합니다.

## 주요 변경사항

### 1. 페이지네이션 쿼리 파라미터 검증

**새 파일: `app/features/products/layouts/leaderboard-layout.tsx`**

```typescript
import { Outlet, data } from "react-router";
import { z } from "zod";
import { Route } from "./+types/leaderboard-layout";

const searchParamsSchema = z.object({
  page: z.coerce.number().min(1).optional().default(1),
});

export const loader = async ({ request }: Route.LoaderArgs) => {
  const url = new URL(request.url);
  const { success, data: parsedData } = searchParamsSchema.safeParse(
    Object.fromEntries(url.searchParams)
  );

  if (!success) {
    throw data(
      {
        error_code: "invalid_page",
        message: "Invalid page",
      },
      { status: 400 }
    );
  }
};

export default function LeaderboardLayout() {
  return <Outlet />;
}
```

**핵심 포인트:**

- **Zod 스키마**: 쿼리 파라미터 검증을 위한 스키마 정의
- **`z.coerce.number()`**: 문자열을 숫자로 자동 변환
- **`.min(1)`**: 최소값 1 보장
- **`.optional().default(1)`**: 없으면 기본값 1
- **`safeParse()`**: 에러를 throw하지 않고 결과 반환
- **에러 처리**: 잘못된 파라미터 시 400 에러 반환

### 2. 페이지네이션 쿼리 함수 수정

**변경된 파일: `app/features/products/queries.ts`**

**Before (limit만 사용):**

```typescript
export const getProductsByDateRange = async ({
  startDate,
  endDate,
  limit,
}: {
  startDate: DateTime;
  endDate: DateTime;
  limit: number;
}) => {
  const { data, error } = await client
    .from("products")
    .select("*")
    .order("stats->>upvotes", { ascending: false })
    .gte("created_at", startDate.toISO())
    .lte("created_at", endDate.toISO())
    .limit(limit);

  if (error) throw error;
  return data;
};
```

**After (range 사용):**

```typescript
import { PAGE_SIZE } from "./contants";

export const getProductsByDateRange = async ({
  startDate,
  endDate,
  limit,
  page = 1,
}: {
  startDate: DateTime;
  endDate: DateTime;
  limit: number;
  page?: number;
}) => {
  const { data, error } = await client
    .from("products")
    .select("*")
    .order("stats->>upvotes", { ascending: false })
    .gte("created_at", startDate.toISO())
    .lte("created_at", endDate.toISO())
    .range((page - 1) * PAGE_SIZE, page * PAGE_SIZE - 1);

  if (error) throw error;
  return data;
};
```

**핵심 포인트:**

- **`range()`**: Supabase의 페이지네이션 메서드
- **`range(start, end)`**: 시작 인덱스와 끝 인덱스 지정
- **계산식**: `(page - 1) * PAGE_SIZE` ~ `page * PAGE_SIZE - 1`
- **예시**: PAGE_SIZE=2, page=1 → range(0, 1), page=2 → range(2, 3)

### 3. 총 페이지 수 계산 함수 추가

**변경된 파일: `app/features/products/queries.ts`**

```typescript
export const getProductPagesByDateRange = async ({
  startDate,
  endDate,
}: {
  startDate: DateTime;
  endDate: DateTime;
}) => {
  const { count, error } = await client
    .from("products")
    .select(`product_id`, { count: "exact", head: true })
    .gte("created_at", startDate.toISO())
    .lte("created_at", endDate.toISO());

  if (error) throw error;
  if (!count) return 1;
  return Math.ceil(count / PAGE_SIZE);
};
```

**핵심 포인트:**

- **`count: "exact"`**: 정확한 개수 조회
- **`head: true`**: 데이터 없이 개수만 조회 (성능 최적화)
- **`Math.ceil()`**: 올림 처리로 총 페이지 수 계산
- **빈 결과 처리**: count가 0이면 1페이지 반환

### 4. 페이지네이션 컴포넌트 수정

**변경된 파일: `app/common/components/product-pagination.tsx`**

```typescript
// Before
const onClick = (page: number) => {
  searchParams.set("page", page.toString());
  setSearchParams(searchParams);
};

// After
const onClick = (page: number) => {
  searchParams.set("page", page.toString());
  setSearchParams(searchParams, { preventScrollReset: true });
};
```

**핵심 포인트:**

- **`preventScrollReset: true`**: 페이지 전환 시 스크롤 위치 유지
- **사용자 경험**: 페이지네이션 클릭 시 상단으로 이동하지 않음

### 5. 페이지 크기 상수 정의

**새 파일: `app/features/products/contants.ts`**

```typescript
export const PAGE_SIZE = 2;
```

**핵심 포인트:**

- **중앙 관리**: 페이지 크기를 한 곳에서 관리
- **일관성**: 모든 페이지네이션에서 동일한 크기 사용

### 6. 리더보드 페이지에 페이지네이션 적용

**변경된 파일: `app/features/products/pages/daily-leaderboard-page.tsx`**

```typescript
export const loader = async ({ params, request }: Route.LoaderArgs) => {
  // ... 파라미터 검증 ...

  const url = new URL(request.url);
  const products = await getProductsByDateRange({
    startDate: date.startOf("day"),
    endDate: date.endOf("day"),
    limit: PAGE_SIZE,
    page: Number(url.searchParams.get("page") || 1),
  });

  const totalPages = await getProductPagesByDateRange({
    startDate: date.startOf("day"),
    endDate: date.endOf("day"),
  });

  return {
    products,
    totalPages,
    ...parsedData,
  };
};

export default function DailyLeaderboardPage({ loaderData }: Route.ComponentProps) {
  return (
    <div>
      {/* ... 제품 목록 ... */}
      <ProductPagination totalPages={loaderData.totalPages} />
    </div>
  );
}
```

**핵심 포인트:**

- **쿼리 파라미터 읽기**: `url.searchParams.get("page")`
- **기본값 처리**: `|| 1`로 기본값 설정
- **총 페이지 수 전달**: `totalPages`를 컴포넌트에 전달

## 우리 프로젝트에 적용하기

### 현재 상태 분석

우리 프로젝트는 현재:

- ✅ React Router 7 사용 중
- ✅ Supabase Client 사용 중
- ✅ 날짜 범위 쿼리 함수 있음 (`getProjectsByDateRange`)
- ❌ 페이지네이션 미구현
- ❌ Zod 검증 미사용
- ❌ 총 페이지 수 계산 미구현

### 적용 전략

#### 1단계: Zod 설치 (필요시)

```bash
npm install zod
```

#### 2단계: 페이지 크기 상수 정의

**파일: `app/features/projects/constants.ts` (새로 생성)**

```typescript
export const PAGE_SIZE = 10; // 프로젝트당 10개씩 표시
```

#### 3단계: 쿼리 함수에 페이지네이션 추가

**파일: `app/features/projects/queries.ts`**

```typescript
import { PAGE_SIZE } from "./constants";

/**
 * 날짜 범위로 프로젝트 조회 (페이지네이션 지원)
 */
export async function getProjectsByDateRange({
  startDate,
  endDate,
  ownerProfileId,
  limit,
  page = 1,
  orderBy = "created_at",
  ascending = false,
}: {
  startDate: string | Date;
  endDate: string | Date;
  ownerProfileId?: string;
  limit: number;
  page?: number;
  orderBy?: "created_at" | "updated_at" | "likes" | "views" | "ctr" | "budget";
  ascending?: boolean;
}) {
  const startDateString =
    startDate instanceof Date ? startDate.toISOString() : startDate;
  const endDateString = endDate instanceof Date ? endDate.toISOString() : endDate;

  let query = client
    .from("project_list_view")
    .select("*")
    .gte("created_at", startDateString)
    .lte("created_at", endDateString)
    .order(orderBy, { ascending })
    .range((page - 1) * PAGE_SIZE, page * PAGE_SIZE - 1); // 페이지네이션 추가

  if (ownerProfileId) {
    query = query.eq("owner_profile_id", ownerProfileId);
  }

  const { data, error } = await query;

  if (error) {
    console.error("날짜 범위 프로젝트 조회 실패:", error);
    throw new Error(
      `프로젝트를 불러오는데 실패했습니다: ${error.message}`
    );
  }

  return data ?? [];
}

/**
 * 날짜 범위의 프로젝트 총 페이지 수 계산
 */
export async function getProjectPagesByDateRange({
  startDate,
  endDate,
  ownerProfileId,
}: {
  startDate: string | Date;
  endDate: string | Date;
  ownerProfileId?: string;
}) {
  const startDateString =
    startDate instanceof Date ? startDate.toISOString() : startDate;
  const endDateString = endDate instanceof Date ? endDate.toISOString() : endDate;

  let query = client
    .from("projects")
    .select("project_id", { count: "exact", head: true })
    .gte("created_at", startDateString)
    .lte("created_at", endDateString);

  if (ownerProfileId) {
    query = query.eq("owner_profile_id", ownerProfileId);
  }

  const { count, error } = await query;

  if (error) {
    console.error("프로젝트 페이지 수 계산 실패:", error);
    throw new Error(
      `페이지 수를 계산하는데 실패했습니다: ${error.message}`
    );
  }

  if (!count || count === 0) return 1;
  return Math.ceil(count / PAGE_SIZE);
}
```

#### 4단계: 프로젝트 목록 페이지에 페이지네이션 추가

**파일: `app/features/projects/pages/project-list-page.tsx`**

```typescript
import { z } from "zod";
import { getProjects, getProjectPages } from "../queries";
import { PAGE_SIZE } from "../constants";
import ProjectPagination from "~/common/components/project-pagination"; // 새로 생성 필요

const searchParamsSchema = z.object({
  page: z.coerce.number().min(1).optional().default(1),
});

export async function loader({ request }: LoaderFunctionArgs) {
  try {
    const url = new URL(request.url);
    const { success, data: parsedData } = searchParamsSchema.safeParse(
      Object.fromEntries(url.searchParams)
    );

    if (!success) {
      throw new Response("Invalid page parameter", { status: 400 });
    }

    const page = parsedData.page;

    const [projects, totalPages] = await Promise.all([
      getProjects(undefined, page),
      getProjectPages(undefined),
    ]);

    return {
      projects: projects ?? [],
      totalPages,
      currentPage: page,
    };
  } catch (error) {
    console.error("프로젝트 목록 로드 실패:", error);
    return {
      projects: [],
      totalPages: 1,
      currentPage: 1,
    };
  }
}

export default function ProjectListPage() {
  const { projects, totalPages, currentPage } = useLoaderData<typeof loader>();

  return (
    <section>
      <h1>프로젝트 목록</h1>
      <div className="grid gap-6">
        {projects.map((project) => (
          <ProjectCard key={project.project_id} {...project} />
        ))}
      </div>
      <ProjectPagination totalPages={totalPages} currentPage={currentPage} />
    </section>
  );
}
```

#### 5단계: getProjects 함수에 페이지네이션 추가

**파일: `app/features/projects/queries.ts`**

```typescript
import { PAGE_SIZE } from "./constants";

/**
 * 모든 프로젝트 목록 조회 (페이지네이션 지원)
 */
export async function getProjects(
  ownerProfileId?: string,
  page: number = 1
) {
  let query = client
    .from("project_list_view")
    .select("*")
    .order("created_at", { ascending: false })
    .range((page - 1) * PAGE_SIZE, page * PAGE_SIZE - 1);

  if (ownerProfileId) {
    query = query.eq("owner_profile_id", ownerProfileId);
  }

  const { data, error } = await query;

  if (error) {
    console.error("프로젝트 조회 실패:", error);
    throw new Error(`프로젝트를 불러오는데 실패했습니다: ${error.message}`);
  }

  return data ?? [];
}

/**
 * 프로젝트 총 페이지 수 계산
 */
export async function getProjectPages(ownerProfileId?: string) {
  let query = client
    .from("projects")
    .select("project_id", { count: "exact", head: true });

  if (ownerProfileId) {
    query = query.eq("owner_profile_id", ownerProfileId);
  }

  const { count, error } = await query;

  if (error) {
    console.error("프로젝트 페이지 수 계산 실패:", error);
    throw new Error(
      `페이지 수를 계산하는데 실패했습니다: ${error.message}`
    );
  }

  if (!count || count === 0) return 1;
  return Math.ceil(count / PAGE_SIZE);
}
```

#### 6단계: 페이지네이션 컴포넌트 생성

**파일: `app/common/components/project-pagination.tsx`**

```typescript
import { useSearchParams } from "react-router";
import { Button } from "~/common/components/ui/button";
import { ChevronLeft, ChevronRight } from "lucide-react";

type ProjectPaginationProps = {
  totalPages: number;
  currentPage?: number;
};

export default function ProjectPagination({
  totalPages,
  currentPage,
}: ProjectPaginationProps) {
  const [searchParams, setSearchParams] = useSearchParams();
  const page = currentPage ?? Number(searchParams.get("page") ?? 1);

  const onClick = (newPage: number) => {
    searchParams.set("page", newPage.toString());
    setSearchParams(searchParams, { preventScrollReset: true });
  };

  if (totalPages <= 1) return null;

  return (
    <div className="flex items-center justify-center gap-2 mt-8">
      <Button
        variant="outline"
        size="sm"
        onClick={() => onClick(page - 1)}
        disabled={page === 1}
      >
        <ChevronLeft className="w-4 h-4" />
        이전
      </Button>

      <div className="flex items-center gap-1">
        {Array.from({ length: totalPages }, (_, i) => i + 1).map((p) => (
          <Button
            key={p}
            variant={p === page ? "default" : "outline"}
            size="sm"
            onClick={() => onClick(p)}
          >
            {p}
          </Button>
        ))}
      </div>

      <Button
        variant="outline"
        size="sm"
        onClick={() => onClick(page + 1)}
        disabled={page === totalPages}
      >
        다음
        <ChevronRight className="w-4 h-4" />
      </Button>
    </div>
  );
}
```

## Supabase range() 메서드 이해하기

### 기본 사용법

```typescript
// 첫 페이지 (0-9번째 항목)
.range(0, 9)

// 두 번째 페이지 (10-19번째 항목)
.range(10, 19)

// 세 번째 페이지 (20-29번째 항목)
.range(20, 29)
```

### 계산 공식

```typescript
const PAGE_SIZE = 10;
const page = 2;

const start = (page - 1) * PAGE_SIZE;  // (2-1) * 10 = 10
const end = page * PAGE_SIZE - 1;      // 2 * 10 - 1 = 19

.range(start, end)  // range(10, 19)
```

### limit() vs range()

**limit() (단순 제한):**
```typescript
.limit(10)  // 항상 처음 10개만
```

**range() (페이지네이션):**
```typescript
.range(0, 9)    // 0-9번째 항목 (1페이지)
.range(10, 19)  // 10-19번째 항목 (2페이지)
```

## Zod 쿼리 파라미터 검증 패턴

### 기본 패턴

```typescript
import { z } from "zod";

const searchParamsSchema = z.object({
  page: z.coerce.number().min(1).optional().default(1),
  sort: z.enum(["newest", "oldest", "popular"]).optional().default("newest"),
  filter: z.string().optional(),
});

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const { success, data: parsedData } = searchParamsSchema.safeParse(
    Object.fromEntries(url.searchParams)
  );

  if (!success) {
    throw new Response("Invalid parameters", { status: 400 });
  }

  // parsedData.page, parsedData.sort, parsedData.filter 사용
};
```

### 다양한 검증 패턴

```typescript
// 숫자 변환 및 범위 검증
page: z.coerce.number().int().min(1).max(100)

// 문자열 검증
search: z.string().min(1).max(100)

// 열거형 검증
status: z.enum(["active", "inactive", "pending"])

// 날짜 검증
date: z.coerce.date()

// 불리언 변환
isActive: z.coerce.boolean()
```

## preventScrollReset 이해하기

### 기본 동작

```typescript
// 기본 (스크롤 리셋)
setSearchParams(searchParams);

// 스크롤 위치 유지
setSearchParams(searchParams, { preventScrollReset: true });
```

### 사용 시나리오

**스크롤 리셋 필요:**
- 새 페이지로 이동할 때
- 필터 변경 시
- 검색 결과 변경 시

**스크롤 유지 필요:**
- 페이지네이션 클릭 시
- 정렬 변경 시 (같은 목록 내)
- 탭 전환 시

## 장단점 비교

### range() 사용 장점

- ✅ **정확한 페이지네이션**: 특정 범위의 데이터만 조회
- ✅ **성능 최적화**: 필요한 데이터만 로드
- ✅ **일관성**: Supabase 표준 방법

### range() 사용 단점

- ❌ **복잡성**: 계산식 필요
- ❌ **인덱스 필요**: 정렬 필드에 인덱스 필요
- ❌ **오프셋 문제**: 대량 데이터에서 성능 저하 가능

### Zod 검증 장점

- ✅ **타입 안전성**: 런타임 검증
- ✅ **에러 처리**: 명확한 에러 메시지
- ✅ **자동 변환**: 문자열을 숫자/날짜로 자동 변환

### Zod 검증 단점

- ❌ **의존성 추가**: zod 패키지 필요
- ❌ **복잡성 증가**: 스키마 정의 필요

## 주의사항

1. **인덱스 최적화**
   - 정렬 필드(`orderBy`)에 인덱스 생성
   - 날짜 필드(`created_at`, `updated_at`)에 인덱스 생성

2. **페이지 크기**
   - 너무 작으면 요청이 많아짐
   - 너무 크면 초기 로딩이 느려짐
   - 일반적으로 10-20개 권장

3. **에러 처리**
   - 잘못된 페이지 번호 처리
   - 빈 결과 처리
   - 네트워크 에러 처리

4. **성능 고려**
   - `head: true`로 count만 조회
   - 병렬 로딩 (`Promise.all`)

5. **사용자 경험**
   - `preventScrollReset`으로 스크롤 유지
   - 로딩 상태 표시
   - 빈 페이지 처리

## 다음 단계

1. ✅ Supabase range() 메서드 이해
2. ✅ Zod 쿼리 파라미터 검증 학습
3. ⏳ 페이지네이션 쿼리 함수 구현
4. ⏳ 총 페이지 수 계산 함수 구현
5. ⏳ 페이지네이션 컴포넌트 생성
6. ⏳ 프로젝트 목록에 페이지네이션 적용
7. ⏳ 테스트 및 성능 최적화

## 참고 자료

- [Supabase range() 문서](https://supabase.com/docs/reference/javascript/range)
- [Zod 공식 문서](https://zod.dev/)
- [React Router useSearchParams](https://reactrouter.com/en/main/hooks/use-search-params)
- [PostgreSQL 인덱스 가이드](https://www.postgresql.org/docs/current/indexes.html)

