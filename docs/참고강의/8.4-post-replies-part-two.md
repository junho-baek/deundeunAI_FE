# 8.4 Post Replies part Two

## 커밋 요약

포스트 댓글 기능의 두 번째 부분으로, 중첩 댓글(대댓글) 기능을 구현한 커밋입니다. `topLevelId`를 통한 부모 댓글 참조, Reply 컴포넌트 개선, 조건부 렌더링, Form 리셋 패턴 등을 보여줍니다.

## 주요 변경사항

### 1. 중첩 댓글 기능 구현 (`topLevelId` 지원)

**목적**: 댓글에 대한 답글(대댓글) 기능 구현

**Mutations 변경**:
```typescript
// app/features/community/mutations.ts
export const createReply = async (
  client: SupabaseClient<Database>,
  {
    postId,
    reply,
    userId,
    topLevelId, // 추가: 부모 댓글 ID
  }: { 
    postId: string; 
    reply: string; 
    userId: string; 
    topLevelId?: number // 옵셔널
  }
) => {
  const { error } = await client
    .from("post_replies")
    .insert({
      // topLevelId가 있으면 parent_id로, 없으면 post_id로 설정
      ...(topLevelId ? { parent_id: topLevelId } : { post_id: Number(postId) }),
      reply,
      profile_id: userId,
    });

  if (error) {
    throw error;
  }
};
```

**패턴**:
- `topLevelId`가 있으면 `parent_id`로 설정 (대댓글)
- `topLevelId`가 없으면 `post_id`로 설정 (최상위 댓글)
- 스프레드 연산자와 조건부 객체를 사용한 깔끔한 구현

### 2. Action 함수에서 `topLevelId` 처리

**구현**:
```typescript
// app/features/community/pages/post-page.tsx
const formSchema = z.object({
  reply: z.string().min(1),
  topLevelId: z.coerce.number().optional(), // 추가
});

export const action = async ({ request, params }: Route.ActionArgs) => {
  // ... 검증 로직
  
  const { reply, topLevelId } = data; // topLevelId 추출
  
  await createReply(client, {
    postId: params.postId,
    reply,
    userId,
    topLevelId, // 전달
  });

  return {
    ok: true,
  };
};
```

**패턴**:
- `z.coerce.number().optional()`로 문자열을 숫자로 변환
- Form에서 전달된 `topLevelId`를 그대로 mutations에 전달

### 3. Reply 컴포넌트 개선

**주요 변경사항**:

#### 3.1 `name`과 `username` 구분

**변경 전**:
```typescript
interface ReplyProps {
  username: string; // name과 username이 혼재
  // ...
}

<Link to={`/users/${username}`}>
  <h4 className="font-medium">{username}</h4>
</Link>
```

**변경 후**:
```typescript
interface ReplyProps {
  name: string;      // 표시용 이름
  username: string; // URL용 사용자명
  // ...
}

<Link to={`/users/${username}`}>
  <h4 className="font-medium">{name}</h4>
</Link>
```

**장점**: 표시 이름과 URL 사용자명을 명확히 구분

#### 3.2 Form 리셋 패턴 (`useActionData` + `useEffect`)

**구현**:
```typescript
import { useActionData, useOutletContext } from "react-router";
import { useEffect, useState } from "react";

export function Reply({ ... }: ReplyProps) {
  const actionData = useActionData<typeof action>();
  const [replying, setReplying] = useState(false);
  
  useEffect(() => {
    if (actionData?.ok) {
      setReplying(false); // 댓글 작성 성공 시 폼 닫기
    }
  }, [actionData]);

  // ...
}
```

**패턴**:
- `useActionData`로 action 결과 확인
- `useEffect`로 `actionData.ok`가 `true`일 때 상태 업데이트
- 댓글 작성 성공 시 자동으로 폼 닫기

**장점**:
- 사용자 경험 개선 (댓글 작성 후 폼 자동 닫힘)
- 상태 동기화 자동화

#### 3.3 Outlet Context를 통한 사용자 정보 접근

**구현**:
```typescript
const {
  isLoggedIn,
  name: loggedInName,
  avatar,
} = useOutletContext<{
  isLoggedIn: boolean;
  name: string;
  avatar: string;
}>();

// 사용 예시
<Avatar className="size-14">
  <AvatarFallback>{loggedInName[0]}</AvatarFallback>
  <AvatarImage src={avatar} />
</Avatar>
```

**패턴**:
- `useOutletContext`로 전역 사용자 정보 접근
- Props drilling 없이 사용자 정보 사용 가능

#### 3.4 조건부 렌더링 (로그인한 경우에만 Reply 버튼 표시)

**구현**:
```typescript
{isLoggedIn ? (
  <Button
    variant="ghost"
    className="self-end"
    onClick={toggleReplying}
  >
    <MessageCircleIcon className="size-4" />
    Reply
  </Button>
) : null}
```

**패턴**: 로그인한 사용자만 댓글 작성 가능

#### 3.5 Form에 `method="post"` 명시 및 hidden input 추가

**구현**:
```typescript
{replying && (
  <Form className="flex items-start gap-5 w-3/4" method="post">
    <input type="hidden" name="topLevelId" value={topLevelId} />
    <Avatar className="size-14">
      <AvatarFallback>{loggedInName[0]}</AvatarFallback>
      <AvatarImage src={avatar} />
    </Avatar>
    <div className="flex flex-col gap-5 items-end w-full">
      <Textarea
        autoFocus
        name="reply"
        placeholder="Write a reply"
        className="w-full resize-none"
        rows={5}
      />
      <Button>Reply</Button>
    </div>
  </Form>
)}
```

**패턴**:
- `method="post"` 명시로 POST 요청 보장
- `hidden` input으로 `topLevelId` 전달
- 로그인한 사용자 정보를 Avatar에 표시

#### 3.6 중첩 댓글 렌더링

**구현**:
```typescript
{replies && replies.length > 0 && (
  <div className="pl-20 w-full">
    {replies.map((reply) => (
      <Reply
        name={reply.user.name}
        username={reply.user.username}
        avatarUrl={reply.user.avatar}
        content={reply.reply}
        timestamp={reply.created_at}
        topLevel={false}
        topLevelId={topLevelId} // 부모 댓글 ID 전달
      />
    ))}
  </div>
)}
```

**패턴**:
- `pl-20`으로 들여쓰기하여 계층 구조 표현
- `topLevel={false}`로 대댓글임을 명시
- `topLevelId`를 전달하여 대댓글의 대댓글도 가능하도록 구현

### 4. Post Page에서 Reply 컴포넌트에 props 전달

**변경**:
```typescript
{loaderData.replies.map((reply) => (
  <Reply
    name={reply.user.name}              // 변경: username → name
    username={reply.user.username}       // 추가
    avatarUrl={reply.user.avatar}
    content={reply.reply}
    timestamp={reply.created_at}
    topLevel={true}
    topLevelId={reply.post_reply_id}     // 추가: 최상위 댓글 ID
    replies={reply.post_replies}         // 추가: 중첩 댓글 배열
  />
))}
```

**패턴**:
- `topLevel={true}`로 최상위 댓글임을 명시
- `topLevelId={reply.post_reply_id}`로 대댓글 작성 시 부모 ID 전달
- `replies={reply.post_replies}`로 중첩 댓글 전달

### 5. 불필요한 변수 제거 (`social-complete-page.tsx`)

**변경**:
```typescript
// 변경 전
const { success, data } = paramsSchema.safeParse(params);

// 변경 후
const { success } = paramsSchema.safeParse(params);
```

**패턴**: 사용하지 않는 변수 제거로 코드 정리

## 적용 방안

### ✅ 이미 적용된 패턴

1. **Outlet Context 사용**: `root.tsx`에서 이미 구현됨
2. **조건부 렌더링**: 여러 페이지에서 사용 중
3. **Form에 `method="post"` 명시**: 일부 Form에서 사용 중
4. **Zod 검증**: 여러 페이지에서 사용 중

### 🔄 추가로 적용 가능한 패턴

#### 1. 중첩 댓글/답글 기능 (우선순위: 중간)

**현재 상태**: 프로젝트에 댓글 기능이 없음

**적용 방안**:
- 댓글 기능이 필요한 경우 중첩 구조 지원
- `parent_id`를 통한 계층 구조 구현
- `topLevelId` 패턴 활용

**예시 구조**:
```typescript
// mutations.ts
export const createReply = async (
  client: SupabaseClient<Database>,
  {
    postId,
    reply,
    userId,
    parentId, // 부모 댓글 ID
  }: { 
    postId: string; 
    reply: string; 
    userId: string; 
    parentId?: number 
  }
) => {
  const { error } = await client
    .from("replies")
    .insert({
      ...(parentId ? { parent_id: parentId } : { post_id: Number(postId) }),
      reply,
      user_id: userId,
    });
  // ...
};
```

**장점**:
- 사용자 경험 향상 (대화형 댓글)
- 계층 구조로 논리적 그룹화

#### 2. Form 리셋 패턴 (`useActionData` + `useEffect`) (우선순위: 중간)

**현재 상태**: Form 리셋 패턴이 일부만 적용됨

**적용 방안**:
```typescript
const actionData = useActionData<typeof action>();
const [isOpen, setIsOpen] = useState(false);

useEffect(() => {
  if (actionData?.ok || actionData?.success) {
    setIsOpen(false); // 폼 닫기 또는 리셋
  }
}, [actionData]);
```

**적용 대상**:
- 모달 폼
- 댓글 작성 폼
- 기타 제출 후 상태 변경이 필요한 폼

**장점**:
- 사용자 경험 개선
- 상태 동기화 자동화

#### 3. `name`과 `username` 구분 (우선순위: 낮음)

**현재 상태**: 프로젝트에서 `name`과 `slug`를 사용 중

**적용 방안**: 이미 적절히 구분되어 있음
- `name`: 표시용 이름
- `slug`: URL용 식별자

#### 4. Hidden Input을 통한 데이터 전달 (우선순위: 낮음)

**현재 상태**: 일부 Form에서 사용 중

**적용 방안**:
```typescript
<Form method="post">
  <input type="hidden" name="parentId" value={parentId} />
  {/* 나머지 폼 필드 */}
</Form>
```

**장점**: URL에 노출되지 않고 데이터 전달 가능

#### 5. `z.coerce`를 통한 타입 변환 (우선순위: 낮음)

**현재 상태**: 일부 스키마에서 사용 중

**적용 방안**:
```typescript
const formSchema = z.object({
  id: z.coerce.number(),        // 문자열 → 숫자
  optionalId: z.coerce.number().optional(), // 옵셔널
});
```

**장점**: Form 데이터는 항상 문자열이므로 자동 변환 유용

## 구현 우선순위

### 높음 (즉시 적용 권장)

1. **Form 리셋 패턴 (`useActionData` + `useEffect`)**
   - 영향도: 중간 (UX 개선)
   - 난이도: 낮음
   - 효과: 사용자 경험 향상, 상태 동기화 자동화

### 중간 (점진적 적용)

2. **중첩 댓글/답글 기능**
   - 영향도: 중간 (기능 추가)
   - 난이도: 중간
   - 효과: 사용자 경험 향상, 대화형 댓글 지원

### 낮음 (선택사항)

3. **Hidden Input을 통한 데이터 전달**
   - 영향도: 낮음 (코드 품질)
   - 난이도: 매우 낮음
   - 효과: 깔끔한 데이터 전달

4. **`z.coerce`를 통한 타입 변환**
   - 영향도: 낮음 (코드 품질)
   - 난이도: 매우 낮음
   - 효과: 타입 안정성 향상

## 참고사항

- 중첩 댓글은 무한 깊이까지 가능하도록 구현 가능 (현재는 2단계)
- `useActionData`는 같은 route의 action 결과만 받을 수 있음
- Form 리셋은 `useFetcher`를 사용하는 경우에도 동일하게 적용 가능
- `topLevelId` 패턴은 트리 구조 데이터에 일반적으로 사용됨
- 조건부 렌더링은 보안상 중요 (서버 검증도 필수)

