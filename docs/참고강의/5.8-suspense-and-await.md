# 5.8 Suspense and Await

## 커밋 개요

이 커밋은 React Router의 `defer` 함수와 `Await`, `Suspense` 컴포넌트를 사용하여 점진적 데이터 로딩을 구현합니다. 빠르게 로드되는 데이터는 즉시 표시하고, 느린 데이터는 비동기로 로드하여 사용자 경험을 개선합니다.

## 주요 변경사항

### 1. Loader에서 defer 사용

**Before (동기적 로딩):**

```typescript
// app/features/community/pages/community-page.tsx
export const loader = async () => {
  await new Promise((resolve) => setTimeout(resolve, 10000));
  const topics = await getTopics();
  const posts = await getPosts();
  return { topics, posts };
};
```

**After (점진적 로딩):**

```typescript
// app/features/community/pages/community-page.tsx
import { defer } from "react-router";

export const loader = async () => {
  return defer({
    topics: getTopics(), // Promise를 그대로 반환
    posts: getPosts(), // Promise를 그대로 반환
  });
};
```

**핵심 포인트:**

- `defer`: 데이터를 Promise로 감싸서 반환
- 빠른 데이터는 즉시 표시, 느린 데이터는 비동기 로드
- 모든 데이터가 준비될 때까지 기다리지 않음

### 2. 컴포넌트에서 Await와 Suspense 사용

**Before (loaderData 직접 사용):**

```typescript
export default function CommunityPage({ loaderData }: Route.ComponentProps) {
  const [searchParams, setSearchParams] = useSearchParams();

  return (
    <div>
      {loaderData.posts.map((post) => (
        <PostCard key={post.post_id} {...post} />
      ))}
      {loaderData.topics.map((topic) => (
        <Button key={topic.slug}>{topic.name}</Button>
      ))}
    </div>
  );
}
```

**After (Await와 Suspense 사용):**

```typescript
import { Await, useLoaderData } from "react-router";
import { Suspense } from "react";

export default function CommunityPage() {
  const { topics, posts } = useLoaderData<typeof loader>();
  const [searchParams, setSearchParams] = useSearchParams();

  return (
    <div>
      {/* Posts - Suspense로 감싸서 로딩 상태 처리 */}
      <Suspense fallback={<PostsSkeleton />}>
        <Await resolve={posts}>
          {(resolvedPosts) => (
            <div className="space-y-5">
              {resolvedPosts.map((post) => (
                <PostCard key={post.post_id} {...post} />
              ))}
            </div>
          )}
        </Await>
      </Suspense>

      {/* Topics - Suspense로 감싸서 로딩 상태 처리 */}
      <Suspense fallback={<TopicsSkeleton />}>
        <Await resolve={topics}>
          {(resolvedTopics) => (
            <div className="flex flex-col gap-2 items-start">
              {resolvedTopics.map((topic) => (
                <Button key={topic.slug} asChild variant="link">
                  {topic.name}
                </Button>
              ))}
            </div>
          )}
        </Await>
      </Suspense>
    </div>
  );
}
```

**핵심 포인트:**

- `useLoaderData`: defer된 데이터를 가져옴
- `Await`: Promise가 resolve될 때까지 대기하고 결과를 렌더링
- `Suspense`: Promise가 resolve되는 동안 fallback UI 표시
- 각 데이터를 독립적으로 로드하여 점진적 렌더링 가능

### 3. 쿼리 함수에 지연 추가 (테스트용)

**변경된 파일: `app/features/community/queries.ts`**

```typescript
export const getTopics = async () => {
  await new Promise((resolve) => setTimeout(resolve, 4000)); // 4초 지연
  const { data, error } = await client.from("topics").select("name, slug");
  if (error) throw new Error(error.message);
  return data;
};

export const getPosts = async () => {
  await new Promise((resolve) => setTimeout(resolve, 4000)); // 4초 지연
  const { data, error } = await client
    .from("community_post_list_view")
    .select(`*`);
  if (error) throw new Error(error.message);
  return data;
};
```

**핵심 포인트:**

- 테스트용 지연 추가 (프로덕션에서는 제거)
- 각 쿼리가 독립적으로 실행됨
- 빠른 쿼리는 먼저 표시되고, 느린 쿼리는 나중에 표시됨

## 우리 프로젝트에 적용하기

### 현재 상태 분석

우리 프로젝트는 현재:

- ✅ React Router 7 사용 중
- ✅ Loader 함수 사용 중
- ✅ SSR 지원됨
- ❌ defer/Await 미사용
- ❌ 점진적 로딩 미구현

### 적용 전략

#### 1단계: defer와 Await 이해

**defer의 목적:**

- 빠른 데이터는 즉시 표시
- 느린 데이터는 비동기로 로드
- 사용자가 기다리는 시간 최소화

**Await의 역할:**

- Promise가 resolve될 때까지 대기
- resolve된 데이터를 렌더링
- Suspense와 함께 사용하여 로딩 상태 처리

#### 2단계: Loader에서 defer 사용

**Before (동기적):**

```typescript
// app/features/projects/pages/project-list-page.tsx
export async function loader({ request }: LoaderFunctionArgs) {
  try {
    const projects = await getProjects();
    return { projects: projects ?? [] };
  } catch (error) {
    return { projects: [] };
  }
}
```

**After (점진적):**

```typescript
import { defer } from "react-router";

export async function loader({ request }: LoaderFunctionArgs) {
  // 빠른 데이터는 즉시 로드
  const quickStats = await getProjectStats();

  // 느린 데이터는 defer로 비동기 로드
  return defer({
    quickStats, // 이미 resolve된 데이터
    projects: getProjects(), // Promise (비동기)
  });
}
```

#### 3단계: 컴포넌트에서 Await 사용

**파일: `app/features/projects/pages/project-list-page.tsx`**

```typescript
import { Await, useLoaderData } from "react-router";
import { Suspense } from "react";

export default function ProjectListPage() {
  const { quickStats, projects } = useLoaderData<typeof loader>();

  return (
    <section>
      {/* 빠른 데이터는 즉시 표시 */}
      <div>
        <h2>통계</h2>
        <p>프로젝트 수: {quickStats.projectCount}</p>
      </div>

      {/* 느린 데이터는 Suspense로 감싸서 로딩 표시 */}
      <Suspense fallback={<ProjectListSkeleton />}>
        <Await resolve={projects}>
          {(resolvedProjects) => (
            <div className="grid gap-6">
              {resolvedProjects.map((project) => (
                <ProjectCard key={project.project_id} {...project} />
              ))}
            </div>
          )}
        </Await>
      </Suspense>
    </section>
  );
}
```

#### 4단계: 스켈레톤 컴포넌트 생성

**파일: `app/features/projects/components/project-list-skeleton.tsx`**

```typescript
export function ProjectListSkeleton() {
  return (
    <div className="grid gap-6">
      {[1, 2, 3, 4].map((i) => (
        <div
          key={i}
          className="h-48 w-full animate-pulse rounded-lg bg-muted"
        />
      ))}
    </div>
  );
}
```

#### 5단계: 에러 처리 추가

**Await에서 에러 처리:**

```typescript
import { Await, useLoaderData, useRouteError } from "react-router";
import { Suspense } from "react";

export default function ProjectListPage() {
  const { projects } = useLoaderData<typeof loader>();

  return (
    <Suspense fallback={<ProjectListSkeleton />}>
      <Await resolve={projects} errorElement={<ProjectsError />}>
        {(resolvedProjects) => (
          <div className="grid gap-6">
            {resolvedProjects.map((project) => (
              <ProjectCard key={project.project_id} {...project} />
            ))}
          </div>
        )}
      </Await>
    </Suspense>
  );
}

function ProjectsError() {
  const error = useRouteError();
  return (
    <div className="text-center p-8">
      <p>프로젝트를 불러오는데 실패했습니다.</p>
      {error instanceof Error && <p className="text-sm text-muted-foreground">{error.message}</p>}
    </div>
  );
}
```

## defer와 Await 패턴 설명

### 기본 패턴

```typescript
// 1. Loader에서 defer 사용
export async function loader() {
  return defer({
    fastData: getFastData(),      // 즉시 resolve
    slowData: getSlowData(),      // Promise (비동기)
  });
}

// 2. 컴포넌트에서 Await 사용
export default function Page() {
  const { fastData, slowData } = useLoaderData<typeof loader>();

  return (
    <div>
      {/* 빠른 데이터는 즉시 표시 */}
      <FastComponent data={fastData} />

      {/* 느린 데이터는 Suspense로 감싸기 */}
      <Suspense fallback={<Skeleton />}>
        <Await resolve={slowData}>
          {(resolvedData) => <SlowComponent data={resolvedData} />}
        </Await>
      </Suspense>
    </div>
  );
}
```

### 다양한 패턴

#### 1. 여러 비동기 데이터 독립적으로 로드

```typescript
export async function loader() {
  return defer({
    projects: getProjects(),
    stats: getStats(),
    recentActivity: getRecentActivity(),
  });
}

export default function Page() {
  const { projects, stats, recentActivity } = useLoaderData<typeof loader>();

  return (
    <div>
      {/* 각각 독립적으로 로드 */}
      <Suspense fallback={<ProjectsSkeleton />}>
        <Await resolve={projects}>
          {(data) => <ProjectsList data={data} />}
        </Await>
      </Suspense>

      <Suspense fallback={<StatsSkeleton />}>
        <Await resolve={stats}>
          {(data) => <Stats data={data} />}
        </Await>
      </Suspense>

      <Suspense fallback={<ActivitySkeleton />}>
        <Await resolve={recentActivity}>
          {(data) => <ActivityFeed data={data} />}
        </Await>
      </Suspense>
    </div>
  );
}
```

#### 2. 조건부 defer

```typescript
export async function loader({ request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  const includeAnalytics = url.searchParams.get("analytics") === "true";

  return defer({
    projects: getProjects(),
    // 조건부로 defer
    analytics: includeAnalytics ? getAnalytics() : null,
  });
}

export default function Page() {
  const { projects, analytics } = useLoaderData<typeof loader>();

  return (
    <div>
      <Suspense fallback={<ProjectsSkeleton />}>
        <Await resolve={projects}>
          {(data) => <ProjectsList data={data} />}
        </Await>
      </Suspense>

      {/* 조건부 렌더링 */}
      {analytics && (
        <Suspense fallback={<AnalyticsSkeleton />}>
          <Await resolve={analytics}>
            {(data) => <Analytics data={data} />}
          </Await>
        </Suspense>
      )}
    </div>
  );
}
```

#### 3. 중첩된 Await

```typescript
export async function loader() {
  return defer({
    project: getProject(),
  });
}

export default function Page() {
  const { project } = useLoaderData<typeof loader>();

  return (
    <Suspense fallback={<ProjectSkeleton />}>
      <Await resolve={project}>
        {(projectData) => (
          <div>
            <h1>{projectData.title}</h1>
            {/* 프로젝트 데이터가 로드된 후 관련 데이터 로드 */}
            <Suspense fallback={<AnalyticsSkeleton />}>
              <Await resolve={getProjectAnalytics(projectData.id)}>
                {(analytics) => <Analytics data={analytics} />}
              </Await>
            </Suspense>
          </div>
        )}
      </Await>
    </Suspense>
  );
}
```

## 장단점 비교

### defer/Await 사용 장점

- ✅ **점진적 로딩**: 빠른 데이터를 먼저 표시하여 사용자 경험 개선
- ✅ **병렬 처리**: 여러 데이터를 동시에 로드 가능
- ✅ **로딩 상태 제어**: 각 데이터별로 독립적인 로딩 상태 표시
- ✅ **성능 최적화**: 느린 쿼리가 빠른 쿼리를 블로킹하지 않음

### defer/Await 사용 단점

- ❌ **복잡성 증가**: 코드가 더 복잡해질 수 있음
- ❌ **에러 처리 복잡**: 각 Await마다 에러 처리 필요
- ❌ **타입 안전성**: Promise 타입 추론이 복잡할 수 있음
- ❌ **과도한 사용**: 모든 데이터를 defer할 필요는 없음

### 언제 defer/Await를 사용해야 할까?

**defer/Await 사용 권장:**

- 데이터 로딩 시간이 크게 다른 경우
- 일부 데이터가 빠르게 로드되는 경우
- 사용자가 빠른 피드백을 받아야 하는 경우
- 여러 독립적인 데이터 소스가 있는 경우

**defer/Await 사용 비권장:**

- 모든 데이터가 비슷한 속도로 로드되는 경우
- 간단한 페이지에서 오버엔지니어링이 될 수 있는 경우
- 데이터 간 의존성이 강한 경우

## 주의사항

1. **테스트용 지연 제거**
   - 프로덕션에서는 `setTimeout` 지연 제거
   - 실제 로딩 시간만 표시되도록

2. **에러 처리**
   - 각 `Await`에 `errorElement` 제공
   - 사용자에게 명확한 에러 메시지 표시

3. **타입 안전성**
   - `useLoaderData<typeof loader>()`로 타입 추론
   - Promise 타입을 명시적으로 정의

4. **스켈레톤 UI**
   - 의미 있는 스켈레톤 컴포넌트 제공
   - 실제 컨텐츠와 유사한 레이아웃 유지

5. **성능 고려**
   - 불필요한 defer 사용 방지
   - 빠른 데이터는 즉시 resolve

## 다음 단계

1. ✅ defer/Await 개념 이해
2. ✅ 점진적 로딩 패턴 학습
3. ⏳ Loader에서 defer 적용
4. ⏳ 컴포넌트에서 Await/Suspense 사용
5. ⏳ 스켈레톤 컴포넌트 생성
6. ⏳ 에러 처리 추가
7. ⏳ 테스트 및 성능 측정

## 참고 자료

- [React Router defer 문서](https://reactrouter.com/en/main/guides/deferred)
- [React Router Await 문서](https://reactrouter.com/en/main/components/await)
- [React Suspense 가이드](https://react.dev/reference/react/Suspense)
