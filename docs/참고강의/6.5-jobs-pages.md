# 6.5 Jobs Pages

## 커밋 개요

이 커밋은 Jobs 기능을 구현하고 실제 DB 데이터를 사용하도록 개선합니다. 필터링 기능과 DateTime을 사용한 상대 시간 표시를 구현합니다.

## 주요 변경사항

### 1. 쿼리 함수 생성: `queries.ts`

**새 파일: `app/features/jobs/queries.ts`**

```typescript
import client from "~/supa-client";

export const getJobs = async ({
  limit,
  location,
  type,
  salary,
}: {
  limit: number;
  location?: string;
  type?: string;
  salary?: string;
}) => {
  const baseQuery = client
    .from("jobs")
    .select(`
      job_id,
      position,
      overview,
      company_name,
      company_logo,
      company_location,
      job_type,
      location,
      salary_range,
      created_at
    `)
    .limit(limit);

  if (location) {
    baseQuery.eq("location", location);
  }

  if (type) {
    baseQuery.eq("job_type", type);
  }

  if (salary) {
    baseQuery.eq("salary_range", salary);
  }

  const { data, error } = await baseQuery;

  if (error) {
    throw error;
  }

  return data;
};
```

**핵심 포인트:**
- **조건부 필터링**: `location`, `type`, `salary` 파라미터가 있을 때만 필터 적용
- **직접 테이블 조회**: View 없이 `jobs` 테이블에서 직접 조회
- **에러 처리**: 에러 발생 시 throw

### 2. 홈 페이지에 실제 데이터 적용

**변경된 파일: `app/common/pages/home-page.tsx`**

**Before (Mock 데이터):**
```typescript
export const loader = async () => {
  const products = await getProductsByDateRange({
    startDate: DateTime.now().startOf("day"),
    endDate: DateTime.now().endOf("day"),
    limit: 7,
  });
  const posts = await getPosts({ limit: 7, sorting: "newest" });
  const ideas = await getGptIdeas({ limit: 7 });
  return { products, posts, ideas };
};

// 컴포넌트에서
{Array.from({ length: 11 }).map((_, index) => (
  <JobCard
    key={`jobId-${index}`}
    id={`jobId-${index}`}
    company="Tesla"
    companyLogoUrl="https://github.com/facebook.png"
    companyHq="San Francisco, CA"
    title="Software Engineer"
    postedAt="12 hours ago"
    type="Full-time"
    positionLocation="Remote"
    salary="$100,000 - $120,000"
  />
))}
```

**After (실제 데이터):**
```typescript
import { getJobs } from "~/features/jobs/queries";

export const loader = async () => {
  const products = await getProductsByDateRange({
    startDate: DateTime.now().startOf("day"),
    endDate: DateTime.now().endOf("day"),
    limit: 7,
  });
  const posts = await getPosts({ limit: 7, sorting: "newest" });
  const ideas = await getGptIdeas({ limit: 7 });
  const jobs = await getJobs({ limit: 11 });
  return { products, posts, ideas, jobs };
};

// 컴포넌트에서
{loaderData.jobs.map((job) => (
  <JobCard
    key={job.job_id}
    id={job.job_id}
    company={job.company_name}
    companyLogoUrl={job.company_logo}
    companyHq={job.company_location}
    title={job.position}
    postedAt={job.created_at}
    type={job.job_type}
    positionLocation={job.location}
    salary={job.salary_range}
  />
))}
```

**핵심 포인트:**
- 더미 데이터 대신 실제 DB 데이터 사용
- Loader에서 병렬로 데이터 로드

### 3. JobCard 컴포넌트 개선

**변경된 파일: `app/features/jobs/components/job-card.tsx`**

**Before:**
```typescript
interface JobCardProps {
  id: string;
  postedAt: string;
}

export function JobCard({ id, postedAt }: JobCardProps) {
  return (
    <Card>
      <span>{postedAt}</span>
      <Badge variant="outline">{type}</Badge>
      <Badge variant="outline">{positionLocation}</Badge>
    </Card>
  );
}
```

**After:**
```typescript
import { DateTime } from "luxon";

interface JobCardProps {
  id: number; // job_id는 number 타입
  postedAt: string;
}

export function JobCard({ id, postedAt, type, positionLocation }: JobCardProps) {
  return (
    <Card>
      <span>{DateTime.fromISO(postedAt).toRelative()}</span>
      <Badge variant="outline" className="capitalize">
        {type}
      </Badge>
      <Badge variant="outline" className="capitalize">
        {positionLocation}
      </Badge>
    </Card>
  );
}
```

**핵심 포인트:**
- **타입 변경**: `id`를 `string`에서 `number`로 변경 (DB 타입과 일치)
- **DateTime 사용**: ISO 문자열을 상대 시간으로 변환 (`toRelative()`)
- **Capitalize 스타일**: `className="capitalize"`로 첫 글자 대문자 처리

### 4. Jobs 페이지에 필터링 기능 추가

**변경된 파일: `app/features/jobs/pages/jobs-page.tsx`**

**Before:**
```typescript
export default function JobsPage() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  return (
    <div>
      <Hero title="Jobs" subtitle="Companies looking for makers" />
      <div>
        {Array.from({ length: 20 }).map((_, index) => (
          <JobCard
            key={`jobId-${index}`}
            id={`jobId-${index}`}
            company="Tesla"
            // ...
          />
        ))}
      </div>
    </div>
  );
}
```

**After:**
```typescript
import { getJobs } from "../queries";
import { JOB_TYPES, LOCATION_TYPES, SALARY_RANGE } from "../constants";
import { z } from "zod";
import { data } from "react-router";

const searchParamsSchema = z.object({
  type: z
    .enum(JOB_TYPES.map((type) => type.value) as [string, ...string[]])
    .optional(),
  location: z
    .enum(LOCATION_TYPES.map((type) => type.value) as [string, ...string[]])
    .optional(),
  salary: z.enum(SALARY_RANGE).optional(),
});

export const loader = async ({ request }: Route.LoaderArgs) => {
  const url = new URL(request.url);
  const { success, data: parsedData } = searchParamsSchema.safeParse(
    Object.fromEntries(url.searchParams)
  );

  if (!success) {
    throw data(
      {
        error_code: "invalid_search_params",
        message: "Invalid search params",
      },
      { status: 400 }
    );
  }

  const jobs = await getJobs({
    limit: 40,
    location: parsedData.location,
    type: parsedData.type,
    salary: parsedData.salary,
  });

  return { jobs };
};

export default function JobsPage({ loaderData }: Route.ComponentProps) {
  const [searchParams, setSearchParams] = useSearchParams();
  
  return (
    <div>
      <Hero title="Jobs" subtitle="Companies looking for makers" />
      <div>
        {loaderData.jobs.map((job) => (
          <JobCard
            key={job.job_id}
            id={job.job_id}
            company={job.company_name}
            // ...
          />
        ))}
      </div>
    </div>
  );
}
```

**핵심 포인트:**
- **Zod 검증**: 쿼리 파라미터를 Zod 스키마로 검증
- **동적 enum**: `JOB_TYPES`, `LOCATION_TYPES` 배열에서 enum 값 추출
- **에러 처리**: 잘못된 파라미터 시 400 에러 반환
- **조건부 필터링**: 파라미터가 있을 때만 필터 적용

## 우리 프로젝트에 적용하기

### 현재 상태 분석

우리 프로젝트는 현재:
- ✅ Supabase 클라이언트 사용 중
- ✅ Loader 함수 사용 중
- ✅ Zod를 사용한 검증 패턴 적용 중
- ✅ 프로젝트 목록에 필터링 기능 구현됨
- ❌ DateTime을 사용한 상대 시간 표시 미구현
- ❌ 조건부 필터링 패턴 미적용

### 적용 전략

#### 1단계: 조건부 필터링 패턴 이해

**기본 패턴:**
```typescript
const baseQuery = client
  .from("table_name")
  .select("*")
  .limit(limit);

if (filter1) {
  baseQuery.eq("field1", filter1);
}

if (filter2) {
  baseQuery.eq("field2", filter2);
}

const { data, error } = await baseQuery;
```

**핵심 포인트:**
- 쿼리 빌더 패턴으로 조건부 필터링
- 각 필터가 선택적(optional)일 때 유용
- View 없이 직접 테이블 조회 가능

#### 2단계: Zod 동적 enum 패턴

**상수 배열에서 enum 추출:**
```typescript
const OPTIONS = [
  { value: "option1", label: "Option 1" },
  { value: "option2", label: "Option 2" },
] as const;

const schema = z.object({
  option: z
    .enum(OPTIONS.map((opt) => opt.value) as [string, ...string[]])
    .optional(),
});
```

**핵심 포인트:**
- 상수 배열에서 enum 값 추출
- `as [string, ...string[]]`로 타입 단언 (최소 1개 요소 필요)
- `.optional()`로 선택적 필터 처리

#### 3단계: Badge Capitalize 스타일

**CSS 클래스 활용:**
```typescript
<Badge variant="outline" className="capitalize">
  {type}
</Badge>
```

**핵심 포인트:**
- Tailwind의 `capitalize` 클래스로 첫 글자 대문자 처리
- DB에 저장된 소문자 값을 표시할 때 유용

## 필터링 패턴

### 기본 패턴

```typescript
export const getItems = async ({
  limit,
  filter1,
  filter2,
  filter3,
}: {
  limit: number;
  filter1?: string;
  filter2?: string;
  filter3?: string;
}) => {
  const baseQuery = client
    .from("table_name")
    .select("*")
    .limit(limit);

  if (filter1) {
    baseQuery.eq("field1", filter1);
  }

  if (filter2) {
    baseQuery.eq("field2", filter2);
  }

  if (filter3) {
    baseQuery.eq("field3", filter3);
  }

  const { data, error } = await baseQuery;

  if (error) {
    throw error;
  }

  return data;
};
```

### Zod 검증 패턴

```typescript
import { z } from "zod";

const searchParamsSchema = z.object({
  filter1: z.enum(["value1", "value2"]).optional(),
  filter2: z.enum(["value3", "value4"]).optional(),
  filter3: z.string().optional(),
});

export const loader = async ({ request }: Route.LoaderArgs) => {
  const url = new URL(request.url);
  const { success, data: parsedData } = searchParamsSchema.safeParse(
    Object.fromEntries(url.searchParams)
  );

  if (!success) {
    throw data(
      {
        error_code: "invalid_search_params",
        message: "Invalid search params",
      },
      { status: 400 }
    );
  }

  const items = await getItems({
    limit: 40,
    filter1: parsedData.filter1,
    filter2: parsedData.filter2,
    filter3: parsedData.filter3,
  });

  return { items };
};
```

### 동적 enum 패턴

```typescript
const FILTER_OPTIONS = [
  { value: "option1", label: "Option 1" },
  { value: "option2", label: "Option 2" },
] as const;

const schema = z.object({
  filter: z
    .enum(FILTER_OPTIONS.map((opt) => opt.value) as [string, ...string[]])
    .optional(),
});
```

## 장점

1. **조건부 필터링**: 필요한 필터만 적용하여 유연성 향상
2. **타입 안전성**: Zod로 쿼리 파라미터 검증
3. **직접 테이블 조회**: View 없이도 간단한 필터링 가능
4. **사용자 경험**: 상대 시간 표시로 더 직관적

## 주의사항

1. **타입 일치**: DB 타입과 TypeScript 타입 일치 확인
2. **enum 타입 단언**: `as [string, ...string[]]`로 최소 1개 요소 보장
3. **에러 처리**: 잘못된 파라미터 시 명확한 에러 메시지
4. **성능**: 필터가 많을 경우 인덱스 확인 필요

## 다음 단계

1. ✅ 조건부 필터링 패턴 이해
2. ✅ Zod 동적 enum 패턴 학습
3. ⏳ Jobs 검색 기능 추가
4. ⏳ Jobs 정렬 기능 추가
5. ⏳ Jobs 페이지네이션 추가
6. ⏳ Jobs 상세 페이지 구현

## 참고 자료

- [Supabase 필터링 문서](https://supabase.com/docs/reference/javascript/filter)
- [Zod enum 문서](https://zod.dev/?id=z-enum)
- [Tailwind capitalize 클래스](https://tailwindcss.com/docs/text-transform)

