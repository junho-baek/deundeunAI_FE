# 5.10 clientLoader

## 커밋 개요

이 커밋은 React Router의 `clientLoader`를 사용하여 클라이언트 사이드에서 데이터를 로드하는 패턴을 구현합니다. 서버 사이드 `loader`와 클라이언트 사이드 `clientLoader`를 함께 사용하여 하이브리드 데이터 페칭을 구현하고, 사용자 경험을 개선합니다.

## 주요 변경사항

### 1. clientLoader 함수 추가

**변경된 파일: `app/features/community/pages/community-page.tsx`**

**Before (서버 사이드만):**

```typescript
export const loader = async () => {
  const [topics, posts] = await Promise.all([getTopics(), getPosts()]);
  return { topics, posts };
};
```

**After (서버 + 클라이언트 하이브리드):**

```typescript
export const loader = async () => {
  const topics = await getTopics();
  const posts = getPosts(); // Promise 반환 (비동기)
  return { topics, posts };
};

export const clientLoader = async ({
  serverLoader,
}: Route.ClientLoaderArgs) => {
  // 서버 로더 결과를 가져옴
  const serverData = await serverLoader();
  
  // 클라이언트에서 추가 작업 수행 (예: analytics 추적)
  // track analytics
  
  return serverData;
};
```

**핵심 포인트:**

- `loader`: 서버에서 실행되는 데이터 로더
- `clientLoader`: 클라이언트에서 실행되는 데이터 로더
- `serverLoader`: 서버 로더를 호출하는 함수
- 클라이언트에서 추가 작업(analytics, 캐싱 등) 수행 가능

### 2. Suspense/Await 제거

**Before (Suspense/Await 사용):**

```typescript
import { Await, useLoaderData } from "react-router";
import { Suspense } from "react";

export default function CommunityPage({ loaderData }: Route.ComponentProps) {
  const { topics, posts } = loaderData;
  
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Await resolve={posts}>
        {(data) => (
          <div className="space-y-5">
            {data.map((post) => (
              <PostCard key={post.post_id} {...post} />
            ))}
          </div>
        )}
      </Await>
    </Suspense>
  );
}
```

**After (직접 데이터 사용):**

```typescript
export default function CommunityPage({ loaderData }: Route.ComponentProps) {
  const { topics, posts } = loaderData;
  
  return (
    <div className="space-y-5">
      {posts.map((post) => (
        <PostCard key={post.post_id} {...post} />
      ))}
    </div>
  );
}
```

**핵심 포인트:**

- `clientLoader`를 사용하면 클라이언트에서 데이터가 이미 resolve되어 있음
- `Suspense`/`Await` 불필요
- 더 간단한 코드 구조

### 3. Link prefetch 추가

**변경된 파일: `app/common/pages/home-page.tsx`**

```typescript
// Before
<Link to="/teams">Explore all teams &rarr;</Link>

// After
<Link prefetch="viewport" to="/teams">
  Explore all teams &rarr;
</Link>
```

**핵심 포인트:**

- `prefetch="viewport"`: 링크가 뷰포트에 들어오면 미리 로드
- 페이지 전환 속도 개선
- 사용자 경험 향상

### 4. 테스트용 지연 제거

**변경된 파일: `app/features/community/queries.ts`**

```typescript
export const getTopics = async () => {
  // await new Promise((resolve) => setTimeout(resolve, 4000)); // 제거됨
  const { data, error } = await client.from("topics").select("name, slug");
  if (error) throw new Error(error.message);
  return data;
};

export const getPosts = async () => {
  // await new Promise((resolve) => setTimeout(resolve, 4000)); // 제거됨
  const { data, error } = await client
    .from("community_post_list_view")
    .select(`*`);
  if (error) throw new Error(error.message);
  return data;
};
```

**핵심 포인트:**

- 프로덕션 코드에서 테스트용 지연 제거
- 실제 성능 반영

## clientLoader 이해하기

### clientLoader의 역할

1. **클라이언트 사이드 데이터 페칭**
   - 클라이언트에서 추가 데이터 로드
   - 서버 데이터와 병합 가능

2. **서버 데이터 재사용**
   - `serverLoader()`로 서버 데이터 가져오기
   - 클라이언트에서 추가 처리

3. **클라이언트 전용 작업**
   - Analytics 추적
   - 클라이언트 캐싱
   - 실시간 데이터 업데이트

### clientLoader 실행 순서

```
1. 서버에서 loader 실행
   ↓
2. HTML 렌더링 (서버 데이터 포함)
   ↓
3. 클라이언트에서 hydration
   ↓
4. clientLoader 실행 (선택적)
   ↓
5. 클라이언트 데이터로 업데이트
```

### loader vs clientLoader

| 구분 | loader | clientLoader |
|------|--------|--------------|
| 실행 위치 | 서버 | 클라이언트 |
| 실행 시점 | 페이지 요청 시 | 클라이언트 hydration 후 |
| 데이터 접근 | DB, API 직접 접근 | `serverLoader()` 사용 |
| SEO | ✅ 지원 | ❌ 지원 안 함 |
| 초기 로딩 | ✅ 빠름 | ❌ 느릴 수 있음 |
| 실시간 업데이트 | ❌ 어려움 | ✅ 쉬움 |

## 우리 프로젝트에 적용하기

### 현재 상태 분석

우리 프로젝트는 현재:

- ✅ React Router 7 사용 중
- ✅ Loader 함수 사용 중
- ✅ SSR 지원됨
- ❌ clientLoader 미사용
- ❌ 클라이언트 사이드 데이터 페칭 미구현

### 적용 전략

#### 1단계: clientLoader 기본 패턴 이해

**기본 구조:**

```typescript
export const loader = async ({ request }: LoaderFunctionArgs) => {
  // 서버에서 데이터 로드
  const data = await getData();
  return { data };
};

export const clientLoader = async ({
  serverLoader,
}: Route.ClientLoaderArgs) => {
  // 서버 데이터 가져오기
  const serverData = await serverLoader();
  
  // 클라이언트에서 추가 작업
  // 예: analytics, 캐싱, 실시간 업데이트 등
  
  return serverData; // 또는 수정된 데이터 반환
};
```

#### 2단계: 대시보드에 clientLoader 적용

**파일: `app/features/dashboard/pages/dashboard-page.tsx`**

```typescript
export async function loader({ request }: LoaderFunctionArgs) {
  try {
    const ownerProfileId = undefined;
    
    // 빠른 데이터는 즉시 로드
    const stats = await getProjectStats(undefined);
    
    // 느린 데이터는 Promise로 비동기 로드
    return {
      stats,
      recentProjects: getRecentProjects(14, undefined, 10),
      metricWidgets: getMetricWidgets(ownerProfileId),
      insights: getInsightsFromActivityFeed(ownerProfileId, 3),
    };
  } catch (error) {
    console.error("대시보드 데이터 로드 실패:", error);
    return {
      stats: {
        totalLikes: 0,
        totalViews: 0,
        averageCTR: 0,
        totalBudget: 0,
        projectCount: 0,
      },
      recentProjects: Promise.resolve([]),
      metricWidgets: Promise.resolve([]),
      insights: Promise.resolve([]),
    };
  }
}

export const clientLoader = async ({
  serverLoader,
}: Route.ClientLoaderArgs) => {
  // 서버 데이터 가져오기
  const serverData = await serverLoader();
  
  // 클라이언트에서 추가 작업
  // 예: 페이지뷰 추적
  if (typeof window !== "undefined") {
    // analytics.track("dashboard_viewed");
  }
  
  // 클라이언트에서 추가 데이터 로드 (선택적)
  // 예: 실시간 알림, 사용자 설정 등
  
  return serverData;
};
```

#### 3단계: 프로젝트 목록에 clientLoader 적용

**파일: `app/features/projects/pages/project-list-page.tsx`**

```typescript
export async function loader({ request }: LoaderFunctionArgs) {
  try {
    const projects = await getProjects();
    return {
      projects: projects ?? [],
    };
  } catch (error) {
    console.error("프로젝트 목록 로드 실패:", error);
    return {
      projects: [],
    };
  }
}

export const clientLoader = async ({
  serverLoader,
}: Route.ClientLoaderArgs) => {
  const serverData = await serverLoader();
  
  // 클라이언트에서 추가 작업
  // 예: 최근 본 프로젝트 추적, 필터링 등
  
  return serverData;
};
```

#### 4단계: Link prefetch 추가

**파일: `app/features/dashboard/pages/dashboard-page.tsx`**

```typescript
import { Link } from "react-router";

export default function DashboardPage() {
  return (
    <div>
      {/* 뷰포트에 들어오면 미리 로드 */}
      <Link prefetch="viewport" to="/my/dashboard/project">
        프로젝트 보기
      </Link>
      
      {/* 항상 미리 로드 (주의: 트래픽 증가) */}
      <Link prefetch="intent" to="/my/dashboard/settings/profile">
        설정
      </Link>
      
      {/* 미리 로드 안 함 (기본값) */}
      <Link to="/my/dashboard/project/create">
        프로젝트 생성
      </Link>
    </div>
  );
}
```

**prefetch 옵션:**

- `"viewport"`: 링크가 뷰포트에 들어오면 미리 로드
- `"intent"`: 사용자가 링크에 마우스를 올리면 미리 로드
- `undefined` (기본값): 미리 로드 안 함

## clientLoader 사용 패턴

### 패턴 1: 서버 데이터 재사용

```typescript
export const clientLoader = async ({
  serverLoader,
}: Route.ClientLoaderArgs) => {
  const serverData = await serverLoader();
  
  // 서버 데이터 그대로 사용
  return serverData;
};
```

### 패턴 2: 클라이언트에서 데이터 추가

```typescript
export const clientLoader = async ({
  serverLoader,
}: Route.ClientLoaderArgs) => {
  const serverData = await serverLoader();
  
  // 클라이언트에서 추가 데이터 로드
  const clientData = await fetchClientData();
  
  return {
    ...serverData,
    clientData,
  };
};
```

### 패턴 3: 서버 데이터 수정

```typescript
export const clientLoader = async ({
  serverLoader,
}: Route.ClientLoaderArgs) => {
  const serverData = await serverLoader();
  
  // 클라이언트에서 데이터 수정
  const modifiedData = {
    ...serverData,
    projects: serverData.projects.map((project) => ({
      ...project,
      // 클라이언트 전용 필드 추가
      isFavorite: checkIfFavorite(project.id),
    })),
  };
  
  return modifiedData;
};
```

### 패턴 4: 조건부 클라이언트 로딩

```typescript
export const clientLoader = async ({
  serverLoader,
  request,
}: Route.ClientLoaderArgs) => {
  const serverData = await serverLoader();
  
  // 조건에 따라 클라이언트에서 추가 데이터 로드
  const url = new URL(request.url);
  const includeAnalytics = url.searchParams.get("analytics") === "true";
  
  if (includeAnalytics) {
    const analytics = await fetchAnalytics();
    return {
      ...serverData,
      analytics,
    };
  }
  
  return serverData;
};
```

### 패턴 5: 에러 처리

```typescript
export const clientLoader = async ({
  serverLoader,
}: Route.ClientLoaderArgs) => {
  try {
    const serverData = await serverLoader();
    return serverData;
  } catch (error) {
    // 클라이언트에서 에러 처리
    console.error("클라이언트 로더 에러:", error);
    
    // 기본값 반환 또는 에러 페이지로 리다이렉트
    return {
      projects: [],
      error: "데이터를 불러오는데 실패했습니다.",
    };
  }
};
```

## 장단점 비교

### clientLoader 사용 장점

- ✅ **클라이언트 전용 작업**: Analytics, 실시간 업데이트 등
- ✅ **서버 데이터 재사용**: `serverLoader()`로 서버 데이터 활용
- ✅ **유연한 데이터 처리**: 클라이언트에서 데이터 수정/추가 가능
- ✅ **간단한 코드**: Suspense/Await 불필요

### clientLoader 사용 단점

- ❌ **SEO 제한**: 클라이언트 데이터는 검색 엔진에 노출 안 됨
- ❌ **초기 로딩**: 서버 데이터만 먼저 표시됨
- ❌ **복잡성 증가**: loader와 clientLoader 두 개 관리 필요
- ❌ **중복 로딩**: 서버와 클라이언트에서 모두 실행될 수 있음

### 언제 clientLoader를 사용해야 할까?

**clientLoader 사용 권장:**

- Analytics 추적이 필요한 경우
- 클라이언트 전용 데이터가 필요한 경우
- 실시간 업데이트가 필요한 경우
- 사용자 설정/캐싱이 필요한 경우

**clientLoader 사용 비권장:**

- SEO가 중요한 경우
- 초기 로딩 속도가 중요한 경우
- 서버 데이터만으로 충분한 경우
- 단순한 정적 페이지인 경우

## Link prefetch 전략

### prefetch="viewport"

```typescript
<Link prefetch="viewport" to="/dashboard">
  대시보드
</Link>
```

**사용 시기:**
- 사용자가 자주 방문하는 페이지
- 중요한 네비게이션 링크
- 뷰포트에 보이는 링크

### prefetch="intent"

```typescript
<Link prefetch="intent" to="/settings">
  설정
</Link>
```

**사용 시기:**
- 사용자가 클릭할 가능성이 높은 링크
- 호버 시 즉시 로드하고 싶은 링크

### prefetch 없음 (기본값)

```typescript
<Link to="/admin">
  관리자 페이지
</Link>
```

**사용 시기:**
- 자주 방문하지 않는 페이지
- 트래픽을 절약하고 싶은 경우
- 민감한 데이터가 있는 페이지

## 주의사항

1. **서버 데이터 우선**
   - 중요한 데이터는 서버 `loader`에서 로드
   - 클라이언트는 보조적인 역할만

2. **에러 처리**
   - `clientLoader`에서 에러 발생 시 적절히 처리
   - 사용자에게 명확한 피드백 제공

3. **성능 고려**
   - 불필요한 클라이언트 로딩 방지
   - `serverLoader()` 재사용으로 중복 방지

4. **타입 안전성**
   - `Route.ClientLoaderArgs` 타입 사용
   - 반환 타입 명시

5. **테스트**
   - 서버와 클라이언트 모두 테스트
   - 에러 케이스 테스트

## 다음 단계

1. ✅ clientLoader 개념 이해
2. ✅ 서버/클라이언트 하이브리드 패턴 학습
3. ⏳ Loader에 clientLoader 추가
4. ⏳ Link prefetch 적용
5. ⏳ Analytics 추적 구현
6. ⏳ 클라이언트 캐싱 구현
7. ⏳ 테스트 및 성능 측정

## 참고 자료

- [React Router clientLoader 문서](https://reactrouter.com/en/main/route/client-loader)
- [React Router Link prefetch 문서](https://reactrouter.com/en/main/components/link#prefetch)
- [React Router Data Loading 가이드](https://reactrouter.com/en/main/guides/data-loading)

