# 8.3 Post Replies part One

## 커밋 요약

포스트 댓글 기능을 구현한 커밋입니다. Mutations에 댓글 생성 함수 추가, Action 함수 구현, Form 리셋 패턴, Outlet Context를 통한 사용자 정보 전달 등의 패턴을 보여줍니다.

## 주요 변경사항

### 1. Mutations에 댓글 생성 함수 추가

**구현**:
```typescript
// app/features/community/mutations.ts
export const createReply = async (
  client: SupabaseClient<Database>,
  { postId, reply, userId }: { postId: string; reply: string; userId: string }
) => {
  const { error } = await client
    .from("post_replies")
    .insert({ post_id: Number(postId), reply, profile_id: userId });

  if (error) {
    throw error;
  }
};
```

**특징**:
- 간단한 insert 작업
- 에러는 그대로 throw하여 상위에서 처리
- `postId`를 문자열에서 숫자로 변환 (`Number(postId)`)

### 2. Action 함수 구현

**구현**:
```typescript
const formSchema = z.object({
  reply: z.string().min(1),
});

export const action = async ({ request, params }: Route.ActionArgs) => {
  const { client } = makeSSRClient(request);
  const userId = await getLoggedInUserId(client);

  const formData = await request.formData();
  const { success, error, data } = formSchema.safeParse(
    Object.fromEntries(formData)
  );

  if (!success) {
    return {
      formErrors: error.flatten().fieldErrors,
    };
  }

  const { reply } = data;
  await createReply(client, {
    postId: params.postId,
    reply,
    userId,
  });

  return {
    ok: true,
  };
};
```

**패턴**:
- Zod 스키마로 간단한 검증
- `getLoggedInUserId`로 인증 체크
- 성공 시 `{ ok: true }` 반환 (리다이렉트 없이 같은 페이지 유지)

### 3. Form 리셋 패턴 (`useRef` + `useEffect`)

**구현**:
```typescript
const formRef = useRef<HTMLFormElement>(null);

useEffect(() => {
  if (actionData?.ok) {
    formRef.current?.reset();
  }
}, [actionData?.ok]);
```

**패턴**:
- `useRef`로 Form 요소 참조
- `useEffect`로 `actionData.ok`가 `true`일 때 폼 리셋
- 댓글 작성 후 입력 필드 자동 초기화

**장점**:
- 사용자 경험 개선 (댓글 작성 후 바로 다음 댓글 작성 가능)
- 리다이렉트 없이 같은 페이지 유지하면서 폼만 리셋

### 4. Outlet Context를 통한 사용자 정보 전달

**root.tsx 변경**:
```typescript
<Outlet
  context={{
    isLoggedIn,
    name: loaderData.profile?.name,
    username: loaderData.profile?.username,
    avatar: loaderData.profile?.avatar,
  }}
/>
```

**post-page.tsx에서 사용**:
```typescript
const { isLoggedIn, name, username, avatar } = useOutletContext<{
  isLoggedIn: boolean;
  name?: string;
  username?: string;
  avatar?: string;
}>();
```

**패턴**:
- `root.tsx`의 loader에서 가져온 사용자 정보를 Outlet Context로 전달
- 하위 페이지에서 `useOutletContext`로 접근
- Props drilling 없이 전역 사용자 정보 접근 가능

**장점**:
- Props drilling 방지
- 여러 페이지에서 일관된 사용자 정보 접근
- 로그인 상태에 따른 조건부 렌더링 용이

### 5. 조건부 렌더링 (로그인한 경우에만 폼 표시)

**구현**:
```typescript
{isLoggedIn ? (
  <Form ref={formRef} className="..." method="post">
    <Avatar className="size-14">
      <AvatarFallback>{name?.[0]}</AvatarFallback>
      <AvatarImage src={avatar} />
    </Avatar>
    {/* ... 폼 내용 */}
  </Form>
) : null}
```

**패턴**: 로그인한 경우에만 댓글 작성 폼 표시

### 6. DateTime 처리 개선

**변경 전**:
```typescript
DateTime.fromISO(loaderData.post.created_at, {
  zone: "utc",
}).toRelative({ unit: "hours" })
```

**변경 후**:
```typescript
DateTime.fromISO(loaderData.post.created_at, {
  zone: "utc",
}).toRelative()
```

**장점**: `unit` 옵션 제거로 더 자연스러운 상대 시간 표시 (예: "2 hours ago" → "2 hours ago" 또는 "yesterday")

### 7. Queries에 정렬 추가

**변경**:
```typescript
// app/features/community/queries.ts
.eq("post_id", postId)
.order("created_at", { ascending: false }); // 추가
```

**장점**: 최신 댓글부터 표시

## 적용 방안

### ✅ 이미 적용된 패턴

1. **Mutations 파일 분리**: `app/features/projects/mutations.ts` 생성 완료
2. **`getLoggedInUserId` 사용**: 여러 파일에서 이미 적용됨
3. **Zod 검증**: `project-create-page.tsx`에서 사용 중
4. **Action 함수 패턴**: 여러 페이지에서 사용 중
5. **Form에 `method="post"` 명시**: 일부 Form에서 사용 중

### 🔄 추가로 적용 가능한 패턴

#### 1. Outlet Context를 통한 사용자 정보 전달 (우선순위: 높음)

**현재 상태**: `root.tsx`에 Outlet context가 없음

**적용 방안**:
```typescript
// app/root.tsx
<Outlet
  context={{
    isLoggedIn,
    name: loaderData?.profile?.name,
    username: loaderData?.profile?.slug,
    avatar: loaderData?.profile?.avatar_url,
    creditBalance: loaderData?.creditBalance,
  }}
/>
```

**장점**:
- Props drilling 방지
- 여러 페이지에서 일관된 사용자 정보 접근
- 로그인 상태에 따른 조건부 렌더링 용이

**적용 대상**:
- 모든 페이지에서 사용자 정보가 필요한 경우
- 조건부 렌더링이 필요한 경우

#### 2. Form 리셋 패턴 (`useRef` + `useEffect`) (우선순위: 중간)

**현재 상태**: Form 리셋 패턴이 없음

**적용 방안**:
```typescript
const formRef = useRef<HTMLFormElement>(null);

useEffect(() => {
  if (actionData?.ok || actionData?.success) {
    formRef.current?.reset();
  }
}, [actionData?.ok, actionData?.success]);
```

**장점**:
- 사용자 경험 개선
- 댓글/메시지 작성 후 바로 다음 입력 가능

**적용 대상**:
- 댓글 작성 폼
- 메시지 작성 폼
- 기타 제출 후 리셋이 필요한 폼

#### 3. DateTime 처리 개선 (`unit` 제거) (우선순위: 낮음)

**현재 상태**: 일부 DateTime 처리에 `unit` 옵션 사용

**적용 방안**: `unit` 옵션 제거하여 더 자연스러운 상대 시간 표시

**예시**:
```typescript
// 변경 전
DateTime.fromISO(date, { zone: "utc" }).toRelative({ unit: "hours" })

// 변경 후
DateTime.fromISO(date, { zone: "utc" }).toRelative()
```

**장점**: 더 자연스러운 시간 표시

#### 4. Action에서 `{ ok: true }` 반환 패턴 (우선순위: 낮음)

**현재 상태**: 대부분 redirect 사용

**적용 방안**: 같은 페이지에 머물면서 상태만 업데이트해야 하는 경우 `{ ok: true }` 반환

**예시**:
```typescript
export const action = async ({ request }: Route.ActionArgs) => {
  // ... 처리 로직
  
  return {
    ok: true,
  };
};
```

**장점**: 리다이렉트 없이 같은 페이지 유지하면서 상태 업데이트

**적용 대상**:
- 댓글 작성
- 좋아요/북마크 토글
- 기타 같은 페이지에 머물면서 상태만 변경하는 경우

#### 5. Queries에 정렬 추가 (우선순위: 낮음)

**현재 상태**: 일부 쿼리에 정렬이 없을 수 있음

**적용 방안**: 목록 조회 시 항상 정렬 명시

**예시**:
```typescript
.order("created_at", { ascending: false }) // 최신순
.order("created_at", { ascending: true })  // 오래된순
```

**장점**: 일관된 데이터 순서 보장

## 구현 우선순위

### 높음 (즉시 적용 권장)

1. **Outlet Context를 통한 사용자 정보 전달**
   - 영향도: 높음 (코드 구조 개선)
   - 난이도: 낮음
   - 효과: Props drilling 방지, 일관된 사용자 정보 접근

### 중간 (점진적 적용)

2. **Form 리셋 패턴**
   - 영향도: 중간 (UX 개선)
   - 난이도: 낮음
   - 효과: 사용자 경험 향상

### 낮음 (선택사항)

3. **DateTime 처리 개선**
   - 영향도: 낮음 (UX 개선)
   - 난이도: 매우 낮음
   - 효과: 더 자연스러운 시간 표시

4. **Action에서 `{ ok: true }` 반환 패턴**
   - 영향도: 낮음 (UX 개선)
   - 난이도: 낮음
   - 효과: 같은 페이지 유지하면서 상태 업데이트

5. **Queries에 정렬 추가**
   - 영향도: 낮음 (데이터 일관성)
   - 난이도: 매우 낮음
   - 효과: 일관된 데이터 순서

## 참고사항

- Community 기능은 현재 프로젝트에서 제외되므로, 패턴만 참고하여 프로젝트 관련 기능에 적용
- Outlet Context는 React Router의 표준 패턴이므로 적극 활용 권장
- Form 리셋은 `useFetcher`를 사용하는 경우에도 동일하게 적용 가능
- `{ ok: true }` 반환은 리다이렉트가 필요 없는 경우에만 사용

