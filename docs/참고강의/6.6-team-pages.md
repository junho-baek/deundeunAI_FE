# 6.6 Team Pages

## 커밋 개요

이 커밋은 Teams 기능을 구현하고 실제 DB 데이터를 사용하도록 개선합니다. Supabase의 관계 조회(JOIN) 패턴과 문자열 배열 변환, null 안전 처리를 구현합니다.

## 주요 변경사항

### 1. Schema 변경: 테이블명 변경 및 외래키 추가

**변경된 파일: `app/features/teams/schema.ts`**

**Before:**
```typescript
export const team = pgTable("team", {
  team_id: bigint({ mode: "number" }).primaryKey(),
  roles: text().notNull(),
  product_stage: productStage().notNull(),
  // ...
});
```

**After:**
```typescript
import { profiles } from "../users/schema";

export const team = pgTable("teams", {
  team_id: bigint({ mode: "number" }).primaryKey(),
  roles: text().notNull(),
  product_description: text().notNull(),
  team_leader_id: uuid()
    .references(() => profiles.profile_id, {
      onDelete: "cascade",
    })
    .notNull(),
  created_at: timestamp().notNull().defaultNow(),
  updated_at: timestamp().notNull().defaultNow(),
});
```

**핵심 포인트:**
- **테이블명 변경**: `team` → `teams` (복수형으로 변경)
- **외래키 추가**: `team_leader_id`로 `profiles` 테이블과 관계 설정
- **CASCADE 삭제**: 팀 리더 삭제 시 팀도 함께 삭제

### 2. 마이그레이션 파일 생성

**새 파일: `app/sql/migrations/0010_eminent_cardiac.sql`**

```sql
ALTER TABLE "team" RENAME TO "teams";
ALTER TABLE "teams" ADD COLUMN "team_leader_id" uuid;
ALTER TABLE "teams" ADD CONSTRAINT "teams_team_leader_id_profiles_profile_id_fk" 
  FOREIGN KEY ("team_leader_id") 
  REFERENCES "public"."profiles"("profile_id") 
  ON DELETE cascade ON UPDATE no action;
ALTER TABLE "teams" ALTER COLUMN "team_leader_id" SET NOT NULL;
```

**핵심 포인트:**
- 테이블명 변경 마이그레이션
- 외래키 제약조건 추가
- NOT NULL 제약조건 추가

### 3. 쿼리 함수 생성: 관계 데이터 조회

**새 파일: `app/features/teams/queries.ts`**

```typescript
import client from "~/supa-client";

export const getTeams = async ({ limit }: { limit: number }) => {
  const { data, error } = await client
    .from("teams")
    .select(`
      team_id,
      roles,
      product_description,
      team_leader:profiles!inner(
        username,
        avatar
      )
    `)
    .limit(limit);

  if (error) {
    throw error;
  }

  return data;
};
```

**핵심 포인트:**
- **관계 조회**: `team_leader:profiles!inner(...)`로 JOIN된 데이터 조회
- **`!inner`**: INNER JOIN (팀 리더가 반드시 있어야 함)
- **필드 선택**: 필요한 필드만 선택 (`username`, `avatar`)
- **중첩 구조**: `team_leader` 객체 안에 프로필 데이터 포함

### 4. 홈 페이지에 실제 데이터 적용

**변경된 파일: `app/common/pages/home-page.tsx`**

**Before (Mock 데이터):**
```typescript
export const loader = async () => {
  const products = await getProductsByDateRange({...});
  const posts = await getPosts({...});
  const ideas = await getGptIdeas({ limit: 7 });
  const jobs = await getJobs({ limit: 11 });
  return { products, posts, ideas, jobs };
};

// 컴포넌트에서
{Array.from({ length: 7 }).map((_, index) => (
  <TeamCard
    key={`teamId-${index}`}
    id={`teamId-${index}`}
    leaderUsername="lynn"
    leaderAvatarUrl="https://github.com/inthetiger.png"
    positions={["React Developer", "Backend Developer", "Product Manager"]}
    projectDescription="a new social media platform"
  />
))}
```

**After (실제 데이터):**
```typescript
import { getTeams } from "~/features/teams/queries";

export const loader = async () => {
  const products = await getProductsByDateRange({...});
  const posts = await getPosts({...});
  const ideas = await getGptIdeas({ limit: 7 });
  const jobs = await getJobs({ limit: 11 });
  const teams = await getTeams({ limit: 7 });
  return { products, posts, ideas, jobs, teams };
};

// 컴포넌트에서
{loaderData.teams.map((team) => (
  <TeamCard
    key={team.team_id}
    id={team.team_id}
    leaderUsername={team.team_leader.username}
    leaderAvatarUrl={team.team_leader.avatar}
    positions={team.roles.split(",")}
    projectDescription={team.product_description}
  />
))}
```

**핵심 포인트:**
- 더미 데이터 대신 실제 DB 데이터 사용
- 문자열을 배열로 변환: `team.roles.split(",")`
- 중첩 객체 접근: `team.team_leader.username`

### 5. TeamCard 컴포넌트 개선

**변경된 파일: `app/features/teams/components/team-card.tsx`**

**Before:**
```typescript
interface TeamCardProps {
  id: string;
  leaderAvatarUrl: string;
}

export function TeamCard({ id, leaderAvatarUrl }: TeamCardProps) {
  return (
    <Link to={`/teams/${id}`}>
      <Card>
        <Avatar>
          <AvatarFallback>{leaderUsername[0]}</AvatarFallback>
          <AvatarImage src={leaderAvatarUrl} />
        </Avatar>
      </Card>
    </Link>
  );
}
```

**After:**
```typescript
interface TeamCardProps {
  id: number; // team_id는 number 타입
  leaderAvatarUrl: string | null; // null 가능
}

export function TeamCard({ id, leaderAvatarUrl }: TeamCardProps) {
  return (
    <Link to={`/teams/${id}`} className="block">
      <Card className="bg-transparent hover:bg-card/50 flex flex-col justify-between transition-colors h-full">
        <CardHeader>
          <Avatar>
            <AvatarFallback>{leaderUsername[0]}</AvatarFallback>
            {leaderAvatarUrl ? <AvatarImage src={leaderAvatarUrl} /> : null}
          </Avatar>
        </CardHeader>
      </Card>
    </Link>
  );
}
```

**핵심 포인트:**
- **타입 변경**: `id`를 `string`에서 `number`로 변경 (DB 타입과 일치)
- **Null 안전 처리**: `leaderAvatarUrl`을 `string | null`로 변경하고 조건부 렌더링
- **스타일 개선**: `className="block"` 추가, `flex flex-col justify-between`, `h-full` 추가

### 6. Teams 페이지에 Loader 추가

**변경된 파일: `app/features/teams/pages/teams-page.tsx`**

**Before:**
```typescript
export default function TeamsPage() {
  return (
    <div>
      <Hero title="Teams" subtitle="Find a team looking for a new member." />
      <div>
        {Array.from({ length: 8 }).map((_, index) => (
          <TeamCard
            key={`teamId-${index}`}
            id={`teamId-${index}`}
            // ...
          />
        ))}
      </div>
    </div>
  );
}
```

**After:**
```typescript
import { getTeams } from "../queries";

export const loader = async () => {
  const teams = await getTeams({ limit: 8 });
  return { teams };
};

export default function TeamsPage({ loaderData }: Route.ComponentProps) {
  return (
    <div>
      <Hero title="Teams" subtitle="Find a team looking for a new member." />
      <div>
        {loaderData.teams.map((team) => (
          <TeamCard
            key={team.team_id}
            id={team.team_id}
            leaderUsername={team.team_leader.username}
            leaderAvatarUrl={team.team_leader.avatar}
            positions={team.roles.split(",")}
            projectDescription={team.product_description}
          />
        ))}
      </div>
    </div>
  );
}
```

**핵심 포인트:**
- Loader로 서버 사이드 데이터 로드
- 실제 DB 데이터 사용

## 우리 프로젝트에 적용하기

### 현재 상태 분석

우리 프로젝트는 현재:
- ✅ Supabase 클라이언트 사용 중
- ✅ Loader 함수 사용 중
- ✅ Schema 정의 사용 중
- ❌ 관계 조회(JOIN) 패턴 미사용
- ❌ 문자열 배열 변환 패턴 미적용
- ❌ Null 안전 처리 미완성

### 적용 전략

#### 1단계: Supabase 관계 조회 패턴 이해

**기본 패턴:**
```typescript
.select(`
  field1,
  field2,
  related_table:table_name!inner(
    field1,
    field2
  )
`)
```

**JOIN 타입:**
- `!inner`: INNER JOIN (관계가 반드시 있어야 함)
- `!left`: LEFT JOIN (관계가 없어도 됨)
- 기본값: LEFT JOIN

**중첩 구조:**
```typescript
// 쿼리 결과
{
  team_id: 1,
  roles: "React Developer,Backend Developer",
  team_leader: {
    username: "lynn",
    avatar: "https://..."
  }
}
```

#### 2단계: 문자열 배열 변환 패턴

**기본 패턴:**
```typescript
// DB에 쉼표로 구분된 문자열로 저장
roles: "React Developer,Backend Developer,Product Manager"

// 배열로 변환
positions={team.roles.split(",")}

// 결과: ["React Developer", "Backend Developer", "Product Manager"]
```

**주의사항:**
- 공백 제거: `team.roles.split(",").map(role => role.trim())`
- 빈 값 필터링: `team.roles.split(",").filter(role => role.length > 0)`

#### 3단계: Null 안전 처리 패턴

**조건부 렌더링:**
```typescript
// Before
<AvatarImage src={leaderAvatarUrl} />

// After
{leaderAvatarUrl ? <AvatarImage src={leaderAvatarUrl} /> : null}
```

**타입 정의:**
```typescript
interface TeamCardProps {
  leaderAvatarUrl: string | null; // null 가능 명시
}
```

## 관계 조회 패턴

### 기본 패턴

```typescript
export const getItems = async ({ limit }: { limit: number }) => {
  const { data, error } = await client
    .from("table_name")
    .select(`
      field1,
      field2,
      related_table:foreign_table!inner(
        field1,
        field2
      )
    `)
    .limit(limit);

  if (error) {
    throw error;
  }

  return data;
};
```

### 다양한 JOIN 타입

```typescript
// INNER JOIN (관계가 반드시 있어야 함)
related_table:foreign_table!inner(...)

// LEFT JOIN (관계가 없어도 됨)
related_table:foreign_table!left(...)

// 기본값 (LEFT JOIN)
related_table:foreign_table(...)
```

### 중첩 관계 조회

```typescript
.select(`
  team_id,
  team_leader:profiles!inner(
    username,
    avatar,
    company:companies!left(
      name,
      logo
    )
  )
`)
```

## 문자열 배열 변환 패턴

### 기본 변환

```typescript
// 쉼표로 구분된 문자열
const roles = "React Developer,Backend Developer,Product Manager";

// 배열로 변환
const positions = roles.split(",");
// ["React Developer", " Backend Developer", " Product Manager"]
```

### 공백 제거

```typescript
const positions = roles.split(",").map(role => role.trim());
// ["React Developer", "Backend Developer", "Product Manager"]
```

### 빈 값 필터링

```typescript
const positions = roles
  .split(",")
  .map(role => role.trim())
  .filter(role => role.length > 0);
```

## Null 안전 처리 패턴

### 조건부 렌더링

```typescript
// 이미지
{avatarUrl ? <AvatarImage src={avatarUrl} /> : null}

// 텍스트
{description || "No description"}

// 기본값
{name ?? "Anonymous"}
```

### 타입 정의

```typescript
interface Props {
  avatarUrl: string | null;
  description: string | null;
  name: string | null;
}
```

## 장점

1. **관계 조회**: JOIN을 통해 관련 데이터를 한 번에 조회
2. **타입 안전성**: TypeScript로 관계 타입 정의
3. **성능**: 단일 쿼리로 필요한 데이터 모두 조회
4. **유연성**: 문자열 배열 변환으로 다양한 데이터 형식 지원

## 주의사항

1. **JOIN 타입 선택**: INNER vs LEFT JOIN 선택 시나리오 고려
2. **Null 처리**: 관계 데이터가 없을 수 있는 경우 null 체크 필수
3. **성능**: 중첩 관계가 많을 경우 쿼리 성능 고려
4. **타입 일치**: DB 타입과 TypeScript 타입 일치 확인

## 다음 단계

1. ✅ 관계 조회 패턴 이해
2. ✅ 문자열 배열 변환 패턴 학습
3. ✅ Null 안전 처리 패턴 학습
4. ⏳ Teams 필터링 기능 추가
5. ⏳ Teams 검색 기능 추가
6. ⏳ Teams 상세 페이지 구현

## 참고 자료

- [Supabase 관계 조회 문서](https://supabase.com/docs/reference/javascript/select#query-foreign-tables)
- [Supabase JOIN 타입](https://supabase.com/docs/reference/javascript/select#query-foreign-tables)
- [TypeScript Null 안전 처리](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)

