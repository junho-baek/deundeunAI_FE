# 11.1 OpenAI API

## 커밋 요약

아이디어 자동 생성에 OpenAI Chat Completions와 Zod 응답 파서를 결합했습니다. 관리자 권한 Supabase 클라이언트로 GPT 결과를 `gpt_ideas` 테이블에 저장하고, `/ideas/generate` 라우트를 통해 비동기 로더가 실행되도록 구성했습니다.

## 주요 변경사항

### 1. GPT 아이디어 생성 Loader

**구현**:
```typescript
// app/features/ideas/pages/generate-idea-page.tsx
const IdeaSchema = z.object({
  title: z.string(),
  description: z.string({
    description: "A short description of the idea. 100 characters max.",
  }),
  problem: z.string(),
  solution: z.string(),
  category: z.enum(["tech", "business", "health", "education", "finance", "other"]),
});

export const loader = async () => {
  const completion = await openai.beta.chat.completions.parse({
    model: "gpt-4o",
    messages: [
      { role: "user", content: "Give the name and elevator pitch of startup ideas that can be built by small teams." },
      { role: "user", content: "For example: 'An app that helps you find the best deals on groceries.', or 'A platform to rent a coder per hour.'" },
      { role: "user", content: "Give me 10 ideas." },
    ],
    response_format: zodResponseFormat(ResponseSchema, "potato"),
  });
  // ...
};
```

**패턴**:
- `openai.beta.chat.completions.parse` + `zodResponseFormat`로 LLM 응답을 강타입으로 파싱
- 명시적인 프롬프트 체인으로 예시 제공 후 실제 지시 전달
- 실패 시 `Response.json`으로 에러 반환

**장점**:
- 파싱 에러를 조기에 감지하여 안전한 데이터 흐름 보장
- 비즈니스 요구(아이디어 10개, 100자 설명) 반영된 스키마 문서화
- 리퀘스트/응답 볼륨을 loader 한 곳에서 관리

### 2. GPT 결과 영속화

**구현**:
```typescript
// app/features/ideas/mutations.ts
export const insertIdeas = async (
  client: SupabaseClient<Database>,
  ideas: string[]
) => {
  const { error } = await client.from("gpt_ideas").insert(
    ideas.map((idea) => ({ idea }))
  );
  if (error) {
    throw error;
  }
};
```

**패턴**:
- GPT 출력 → 문자열 배열 → Supabase `insert` 시 `map`으로 payload 변환
- 에러 발생 시 throw하여 loader에서 바로 확인 가능

**장점**:
- 배치 insert로 네트워크 왕복 최소화
- GPT 응답 포맷이 바뀌어도 중간 계층(배열)만 조정하면 됨

### 3. 관리자 권한 Supabase 클라이언트 분리

**구현**:
```typescript
// app/supa-client.ts
export const adminClient = createClient<Database>(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);
```

**패턴**:
- 서비스 롤 키 전용 클라이언트를 별도 export
- GPT 아이디어 저장처럼 RLS를 우회해야 하는 서버 작업 전용

**장점**:
- 사용자 세션과 분리되어 보안 유지
- 서버 환경 변수에 의존하므로 브라우저 번들에 포함되지 않음

### 4. 라우팅 및 페이지 등록

**구현**:
```typescript
// app/routes.ts
...prefix("/ideas", [
  index("features/ideas/pages/ideas-page.tsx"),
  route("/:ideaId", "features/ideas/pages/idea-page.tsx"),
  route("/generate", "features/ideas/pages/generate-idea-page.tsx"),
]),
```

**패턴**:
- `route("/generate", ...)`로 아이디어 생성 엔드포인트 추가
- loader 전용 페이지라 UI 없이 API 스타일 응답도 가능

**장점**:
- 기존 아이디어 섹션 안에서만 접근 가능
- Route-level loader라 캐싱/권한 정책을 중앙에서 조정 가능

### 5. OpenAI SDK 의존성 추가

**변경**:
```json
// package.json
"openai": "^4.77.3"
```

**패턴**:
- 최신 OpenAI Node SDK로 `beta.chat.completions` API 사용
- `package-lock.json`에 transitive dependency 고정

**장점**:
- 공식 SDK가 제공하는 타입과 helper(zodResponseFormat) 활용
- API 버전 관리가 package 수준에서 명시적

## 적용 방안

1. **Zod 기반 응답 검증 확대**  
   - 다른 GPT 연동 지점에서도 `zodResponseFormat`을 채택하면 구조화된 데이터 계약을 재사용 가능.

2. **Admin 클라이언트 표준화**  
   - 백엔드 저장/배치 작업은 `adminClient` 전용 모듈로 통일해 키 노출을 예방.

3. **Batch Insert 추상화**  
   - 유사한 GPT 로그 적재 시 문자열 배열 → insert 매핑 함수 패턴을 재사용하여 코드량을 줄일 수 있음.

4. **LLM Loader 모듈화**  
   - `/ideas/generate`처럼 loader-only 라우트를 별도 디렉터리로 모아 rate limit, 인증 등을 미들웨어화하면 운영 편의성 증가.

