# 5.2 Supabase Client Setup

## 커밋 개요

이 커밋은 Drizzle ORM 기반의 데이터베이스 쿼리를 Supabase 클라이언트를 사용하는 방식으로 전환하는 작업을 포함합니다. Supabase의 타입 안전성과 RLS(Row Level Security) 기능을 활용하기 위한 설정입니다.

## 주요 변경사항

### 1. Supabase 클라이언트 설정 추가

**새로 생성된 파일: `app/supa-client.ts`**

```typescript
import { createClient } from "@supabase/supabase-js";
import { Database } from "database.types";

const client = createClient<Database>(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_ANON_KEY!
);

export default client;
```

**핵심 포인트:**

- `@supabase/supabase-js` 패키지를 사용하여 클라이언트 생성
- `Database` 타입을 제네릭으로 전달하여 타입 안전성 확보
- 환경 변수에서 `SUPABASE_URL`과 `SUPABASE_ANON_KEY` 사용

### 2. Database Types 생성

**새로 생성된 파일: `database.types.ts`**

- Supabase CLI를 사용하여 데이터베이스 스키마에서 TypeScript 타입 자동 생성
- 모든 테이블, 관계, 타입이 자동으로 정의됨

**package.json 스크립트 추가:**

```json
"db:typegen": "supabase gen types typescript --project-id micuqwjpvmdexbwwpixv > database.types.ts"
```

### 3. Dependencies 추가

**package.json에 추가된 패키지:**

- `@supabase/ssr`: "^0.5.2" - 서버 사이드 렌더링 지원
- `@supabase/supabase-js`: "^2.47.5" - Supabase JavaScript 클라이언트

### 4. 쿼리 함수 전환

**Before (Drizzle ORM):**

```typescript
export const getPosts = async () => {
  const allPosts = await db
    .select({
      id: posts.post_id,
      title: posts.title,
      createdAt: posts.created_at,
      topic: topics.name,
      author: profiles.name,
      authorAvatarUrl: profiles.avatar,
      username: profiles.username,
      upvotes: count(postUpvotes.post_id),
    })
    .from(posts)
    .innerJoin(topics, eq(posts.topic_id, topics.topic_id))
    .innerJoin(profiles, eq(posts.profile_id, profiles.profile_id))
    .leftJoin(postUpvotes, eq(posts.post_id, postUpvotes.post_id))
    .groupBy(...)
    .orderBy(asc(posts.post_id));
  return allPosts;
};
```

**After (Supabase Client):**

```typescript
export const getPosts = async () => {
  const { data, error } = await client.from("posts").select(`
    post_id,
    title,
    created_at,
    topic:topics!inner (
      name
    ),
    author:profiles!posts_profile_id_profiles_profile_id_fk!inner (
      name,
      username,
      avatar
    ),
    upvotes:post_upvotes (
      count
    )
  `);

  if (error) throw new Error(error.message);
  return data;
};
```

**주요 차이점:**

- Drizzle의 복잡한 join 구문이 Supabase의 관계 기반 쿼리로 단순화됨
- `!inner` 키워드로 inner join 명시
- 외래 키 관계를 자동으로 인식하여 관계 데이터 조회
- 에러 처리가 명시적으로 추가됨

### 5. 데이터 타입 변경

**Before:**

- `postedAt: Date` - JavaScript Date 객체
- `DateTime.fromJSDate(postedAt).toRelative()` 사용

**After:**

- `postedAt: string` - ISO 8601 문자열
- `DateTime.fromISO(postedAt).toRelative()` 사용

**컴포넌트에서의 변경:**

```typescript
// Before
postedAt={post.createdAt}  // Date 타입

// After
postedAt={post.created_at}  // string 타입 (ISO 8601)
```

### 6. 데이터 구조 변경

**Before:**

```typescript
{
  id: post.id,
  author: post.author,
  authorAvatarUrl: post.authorAvatarUrl,
  category: post.topic,
  postedAt: post.createdAt,
  votesCount: post.upvotes
}
```

**After:**

```typescript
{
  id: post.post_id,
  author: post.author.name,
  authorAvatarUrl: post.author.avatar,
  category: post.topic.name,
  postedAt: post.created_at,
  votesCount: post.upvotes[0].count
}
```

**변경 이유:**

- Supabase는 관계 데이터를 중첩 객체로 반환
- 배열 형태의 집계 결과를 인덱스로 접근 필요

## 우리 프로젝트에 적용하기

### 현재 상태 분석

우리 프로젝트는 현재:

- ✅ Drizzle ORM을 사용 중 (`app/db.ts`)
- ✅ PostgreSQL 데이터베이스 연결 설정 완료
- ✅ Feature별로 schema.ts 파일로 모듈화됨
- ❌ Supabase 클라이언트 미설정
- ❌ Supabase 타입 정의 파일 없음

### 적용 전략

#### 1단계: Supabase 프로젝트 설정 확인

**필수 확인 사항:**

- Supabase 프로젝트가 생성되어 있는지 확인
- `SUPABASE_URL`과 `SUPABASE_ANON_KEY` 환경 변수 준비
- 데이터베이스가 Supabase에 마이그레이션되었는지 확인

**환경 변수 설정 (.env 파일):**

```env
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
DATABASE_URL=postgresql://...  # 기존 Drizzle용 (마이그레이션용으로 유지)
```

#### 2단계: 패키지 설치

```bash
npm install @supabase/supabase-js @supabase/ssr
```

#### 3단계: Supabase 클라이언트 파일 생성

**파일: `app/lib/supa-client.ts`** (또는 `app/supa-client.ts`)

```typescript
import { createClient } from "@supabase/supabase-js";
import type { Database } from "~/database.types";

const client = createClient<Database>(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_ANON_KEY!
);

export default client;
```

**주의사항:**

- `database.types.ts` 파일이 먼저 생성되어야 함
- 타입 경로는 프로젝트 구조에 맞게 조정

#### 4단계: Database Types 생성

**Supabase CLI 설치:**

macOS의 경우 Homebrew를 사용합니다:

```bash
# Homebrew로 Supabase CLI 설치
brew install supabase/tap/supabase
```

다른 운영체제나 설치 방법:

- Windows: `scoop bucket add supabase https://github.com/supabase/scoop-bucket.git` 후 `scoop install supabase`
- Linux: `brew install supabase/tap/supabase` 또는 직접 바이너리 다운로드
- 자세한 내용: https://github.com/supabase/cli#install-the-cli

**설치 확인:**

```bash
supabase --version
```

**타입 생성 스크립트 추가 (package.json):**

```json
{
  "scripts": {
    "db:typegen": "supabase gen types typescript --project-id YOUR_PROJECT_ID > database.types.ts"
  }
}
```

**타입 생성 실행:**

1. Supabase CLI 로그인 (처음 한 번만 필요):

   ```bash
   supabase login
   ```

   브라우저가 열리면 Supabase 계정으로 로그인하세요.

2. Supabase 대시보드에서 프로젝트 ID 확인 (Settings > General > Reference ID)

3. `package.json`의 `YOUR_PROJECT_ID`를 실제 프로젝트 ID로 변경

4. 타입 생성 실행:
   ```bash
   npm run db:typegen
   ```

**또는 직접 실행:**

```bash
supabase gen types typescript --project-id YOUR_PROJECT_ID > database.types.ts
```

**Access Token을 환경 변수로 설정하는 방법 (선택사항):**

Supabase 대시보드에서 Access Token 생성:

1. https://supabase.com/dashboard/account/tokens 접속
2. "Generate new token" 클릭
3. 생성된 토큰을 복사

`.env` 파일에 추가:

```env
SUPABASE_ACCESS_TOKEN=your_access_token_here
```

또는 명령어 실행 시 직접 전달:

```bash
SUPABASE_ACCESS_TOKEN=your_token supabase gen types typescript --project-id YOUR_PROJECT_ID > database.types.ts
```

**생성 위치:**

- 프로젝트 루트에 `database.types.ts` 생성
- 또는 `app/types/database.types.ts`로 생성 후 경로 조정

#### 5단계: 점진적 마이그레이션 전략

**하이브리드 접근 방식 권장:**

1. **새로운 기능**: Supabase 클라이언트 사용
2. **기존 기능**: Drizzle ORM 유지 (점진적 전환)
3. **복잡한 쿼리**: 필요에 따라 선택

**예시 구조:**

```
app/
  lib/
    supa-client.ts          # Supabase 클라이언트
    drizzle-client.ts      # Drizzle 클라이언트 (기존 db.ts)
  features/
    projects/
      queries.ts           # Supabase 쿼리 (새로 작성)
      queries-drizzle.ts   # Drizzle 쿼리 (기존, 점진적 제거)
```

#### 6단계: 쿼리 함수 전환 예시

**우리 프로젝트의 프로젝트 쿼리 전환 예시:**

**Before (Drizzle - 현재):**

```typescript
// app/features/projects/queries.ts
import db from "~/db";
import { projects } from "./schema";
import { eq } from "drizzle-orm";

export async function getProject(projectId: string) {
  const [project] = await db
    .select()
    .from(projects)
    .where(eq(projects.id, projectId))
    .limit(1);

  return project;
}
```

**After (Supabase - 전환 후):**

```typescript
// app/features/projects/queries.ts
import client from "~/lib/supa-client";

export async function getProject(projectId: string) {
  const { data, error } = await client
    .from("projects")
    .select("*")
    .eq("id", projectId)
    .single();

  if (error) throw new Error(error.message);
  return data;
}
```

**관계가 있는 경우:**

```typescript
// 프로젝트와 사용자 프로필을 함께 조회
export async function getProjectWithProfile(projectId: string) {
  const { data, error } = await client
    .from("projects")
    .select(
      `
      *,
      profile:profiles!projects_profile_id_profiles_id_fk (
        id,
        name,
        avatar_url
      )
    `
    )
    .eq("id", projectId)
    .single();

  if (error) throw new Error(error.message);
  return data;
}
```

#### 7단계: 컴포넌트에서의 데이터 처리 변경

**날짜 필드 처리:**

```typescript
// Before
<time>{DateTime.fromJSDate(project.createdAt).toRelative()}</time>

// After
<time>{DateTime.fromISO(project.created_at).toRelative()}</time>
```

**중첩 객체 접근:**

```typescript
// Before
{
  project.authorName;
}

// After
{
  project.profile?.name;
}
```

#### 8단계: 에러 처리 패턴 통일

**권장 에러 처리 패턴:**

```typescript
export async function getProjects() {
  const { data, error } = await client.from("projects").select("*");

  if (error) {
    console.error("프로젝트 조회 실패:", error);
    throw new Error(`프로젝트를 불러오는데 실패했습니다: ${error.message}`);
  }

  return data ?? [];
}
```

## 장단점 비교

### Supabase Client 장점

- ✅ RLS(Row Level Security) 자동 적용
- ✅ 실시간 구독 기능 지원
- ✅ 타입 안전성 (database.types.ts)
- ✅ 관계 쿼리가 간단함
- ✅ 에러 처리 명확함

### Drizzle ORM 장점

- ✅ 복잡한 쿼리 작성 용이
- ✅ 마이그레이션 관리 편리
- ✅ SQL과 유사한 문법
- ✅ 데이터베이스 독립적

### 하이브리드 접근의 이점

- ✅ 점진적 마이그레이션 가능
- ✅ 각 도구의 장점 활용
- ✅ 리스크 최소화

## 주의사항

1. **환경 변수 보안**
   - `.env` 파일을 `.gitignore`에 포함
   - 프로덕션 환경에서는 환경 변수 관리 시스템 사용

2. **타입 동기화**
   - 데이터베이스 스키마 변경 시 `db:typegen` 재실행 필수
   - CI/CD 파이프라인에 타입 생성 단계 추가 고려

3. **RLS 정책 설정**
   - Supabase 대시보드에서 Row Level Security 정책 설정 필요
   - 테스트 환경에서 충분히 검증

4. **날짜 타입 처리**
   - 모든 날짜 필드는 ISO 8601 문자열로 처리
   - 클라이언트에서 필요시 Date 객체로 변환

5. **트랜잭션 처리**
   - Supabase는 트랜잭션 지원이 제한적
   - 복잡한 트랜잭션이 필요한 경우 Drizzle 유지 고려

## 다음 단계

1. ✅ Supabase 프로젝트 생성 및 설정
2. ✅ 패키지 설치 및 클라이언트 생성
3. ✅ Database Types 생성
4. ⏳ 간단한 쿼리부터 Supabase로 전환
5. ⏳ RLS 정책 설정 및 테스트
6. ⏳ 점진적으로 모든 쿼리 전환
7. ⏳ Drizzle 의존성 제거 (선택사항)

## 참고 자료

- [Supabase JavaScript Client 문서](https://supabase.com/docs/reference/javascript/introduction)
- [Supabase TypeScript 타입 생성](https://supabase.com/docs/reference/javascript/typescript-support)
- [Supabase RLS 가이드](https://supabase.com/docs/guides/auth/row-level-security)
