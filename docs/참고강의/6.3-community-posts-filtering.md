# 6.3 Community Posts Filtering

## 커밋 개요

이 커밋은 커뮤니티 포스트 목록에 필터링, 정렬, 검색 기능을 추가하고 실제 DB 데이터를 사용하도록 개선하는 작업을 포함합니다. Zod를 사용한 쿼리 파라미터 검증과 View를 활용한 효율적인 데이터 조회를 구현합니다.

## 주요 변경사항

### 1. View 수정: `community-post-list-view.sql`

**변경 전:**
```sql
CREATE VIEW community_post_list_view AS
SELECT
  posts.post_id,
  posts.title,
  topics.name AS topic,
  profiles.name AS author,
  profiles.avatar AS author_avatar,
  profiles.username AS author_username,
  COUNT(post_upvotes.post_id) AS upvotes
FROM posts
INNER JOIN topics USING (topic_id)
INNER JOIN profiles USING (profile_id)
LEFT JOIN post_upvotes USING (post_id)
GROUP BY posts.post_id, topics.name, profiles.name, profiles.avatar, profiles.username;
```

**변경 후:**
```sql
CREATE OR REPLACE VIEW community_post_list_view AS
SELECT
  posts.post_id,
  posts.title,
  topics.name AS topic,
  topics.slug AS topic_slug,
  profiles.name AS author,
  profiles.avatar AS author_avatar,
  profiles.username AS author_username,
  posts.upvotes
FROM posts
INNER JOIN topics USING (topic_id)
INNER JOIN profiles USING (profile_id);
```

**핵심 포인트:**
- `COUNT(post_upvotes.post_id)` 대신 `posts.upvotes` 직접 사용 (트리거로 관리되는 카운터)
- `topic_slug` 필드 추가 (필터링용)
- `GROUP BY` 제거 (JOIN만으로 충분)
- `CREATE OR REPLACE` 사용 (View 업데이트 용이)

### 2. 쿼리 함수 개선: `getPosts`

**변경 전:**
```typescript
export const getPosts = async () => {
  const { data, error } = await client
    .from("community_post_list_view")
    .select(`*`);

  if (error) throw new Error(error.message);
  return data;
};
```

**변경 후:**
```typescript
export const getPosts = async ({
  limit,
  sorting,
  period = "all",
  keyword,
  topic,
}: {
  limit: number;
  sorting: "newest" | "popular";
  period?: "all" | "today" | "week" | "month" | "year";
  keyword?: string;
  topic?: string;
}) => {
  const baseQuery = client
    .from("community_post_list_view")
    .select(`*`)
    .limit(limit);

  // 정렬 처리
  if (sorting === "newest") {
    baseQuery.order("created_at", { ascending: false });
  } else if (sorting === "popular") {
    // 기간 필터링
    if (period === "all") {
      baseQuery.order("upvotes", { ascending: false });
    } else {
      const today = DateTime.now();
      if (period === "today") {
        baseQuery.gte("created_at", today.startOf("day").toISO());
      } else if (period === "week") {
        baseQuery.gte("created_at", today.startOf("week").toISO());
      } else if (period === "month") {
        baseQuery.gte("created_at", today.startOf("month").toISO());
      } else if (period === "year") {
        baseQuery.gte("created_at", today.startOf("year").toISO());
      }
      baseQuery.order("upvotes", { ascending: false });
    }
  }

  // 키워드 검색
  if (keyword) {
    baseQuery.ilike("title", `%${keyword}%`);
  }

  // 토픽 필터링
  if (topic) {
    baseQuery.eq("topic_slug", topic);
  }

  const { data, error } = await baseQuery;
  if (error) throw new Error(error.message);
  return data;
};
```

**핵심 포인트:**
- 필터링 옵션을 객체로 받아 유연성 확보
- `DateTime` (luxon)을 사용한 날짜 범위 필터링
- `ilike`를 사용한 대소문자 구분 없는 검색
- `topic_slug`를 사용한 토픽 필터링

### 3. Loader에 검증 추가: `community-page.tsx`

**변경 전:**
```typescript
export const loader = async () => {
  const [topics, posts] = await Promise.all([getTopics(), getPosts()]);
  return { topics, posts };
};
```

**변경 후:**
```typescript
const searchParamsSchema = z.object({
  sorting: z.enum(["newest", "popular"]).optional().default("newest"),
  period: z
    .enum(["all", "today", "week", "month", "year"])
    .optional()
    .default("all"),
  keyword: z.string().optional(),
  topic: z.string().optional(),
});

export const loader = async ({ request }: Route.LoaderArgs) => {
  const url = new URL(request.url);
  const { success, data: parsedData } = searchParamsSchema.safeParse(
    Object.fromEntries(url.searchParams)
  );

  if (!success) {
    throw data(
      {
        error_code: "invalid_search_params",
        message: "Invalid search params",
      },
      { status: 400 }
    );
  }

  const [topics, posts] = await Promise.all([
    getTopics(),
    getPosts({
      limit: 20,
      sorting: parsedData.sorting,
      period: parsedData.period,
      keyword: parsedData.keyword,
      topic: parsedData.topic,
    }),
  ]);

  return { topics, posts };
};
```

**핵심 포인트:**
- Zod 스키마로 쿼리 파라미터 검증
- 잘못된 파라미터 시 400 에러 반환
- 기본값 설정으로 안전한 처리

### 4. 홈 페이지에 실제 데이터 사용: `home-page.tsx`

**변경 전:**
```typescript
export const loader = async () => {
  const products = await getProductsByDateRange({
    startDate: DateTime.now().startOf("day"),
    endDate: DateTime.now().endOf("day"),
    limit: 7,
  });
  return { products };
};

// 컴포넌트에서
{Array.from({ length: 11 }).map((_, index) => (
  <PostCard
    key={`postId-${index}`}
    id={index}
    title="What is the best productivity tool?"
    author="Nico"
    // ...
  />
))}
```

**변경 후:**
```typescript
export const loader = async () => {
  const products = await getProductsByDateRange({
    startDate: DateTime.now().startOf("day"),
    endDate: DateTime.now().endOf("day"),
    limit: 7,
  });
  
  const posts = await getPosts({
    limit: 7,
    sorting: "newest",
  });
  
  return { products, posts };
};

// 컴포넌트에서
{loaderData.posts.map((post) => (
  <PostCard
    key={post.post_id}
    id={post.post_id}
    title={post.title}
    author={post.author}
    authorAvatarUrl={post.author_avatar}
    category={post.topic}
    postedAt={post.created_at}
    votesCount={post.upvotes}
  />
))}
```

**핵심 포인트:**
- 더미 데이터 대신 실제 DB 데이터 사용
- View를 통해 JOIN된 데이터를 평탄화된 구조로 받음

### 5. Form 필드명 변경: `community-page.tsx`

**변경 전:**
```typescript
<Input
  type="text"
  name="search"
  placeholder="Search for discussions"
/>
```

**변경 후:**
```typescript
<Input
  type="text"
  name="keyword"
  placeholder="Search for discussions"
/>
```

**핵심 포인트:**
- `name="search"` → `name="keyword"`로 변경하여 쿼리 파라미터와 일치

## 우리 프로젝트에 적용하기

### 현재 상태 분석

우리 프로젝트는 현재:
- ✅ Supabase 클라이언트 사용 중
- ✅ View를 활용한 데이터 조회 패턴 적용 중
- ✅ Zod를 사용한 검증 패턴 적용 중
- ✅ 프로젝트 목록에 페이지네이션 구현됨
- ❌ 필터링/정렬 기능 미구현

### 적용 전략

#### 1단계: View 수정 (필요시)

**현재 View 확인:**
- `project_list_view`가 이미 존재하는지 확인
- 필요한 필드가 모두 포함되어 있는지 확인

**View에 추가할 필드:**
- `topic_slug` (토픽 필터링용)
- 카운터 필드 (트리거로 관리되는 경우)

#### 2단계: 쿼리 함수에 필터링 옵션 추가

**파일: `app/features/projects/queries.ts`**

```typescript
export async function getProjects({
  ownerProfileId,
  page = 1,
  sorting = "newest",
  period = "all",
  keyword,
  status,
}: {
  ownerProfileId?: string;
  page?: number;
  sorting?: "newest" | "popular" | "trending";
  period?: "all" | "today" | "week" | "month" | "year";
  keyword?: string;
  status?: string;
}) {
  const baseQuery = client
    .from("project_list_view")
    .select("*")
    .range((page - 1) * PAGE_SIZE, page * PAGE_SIZE - 1);

  // 소유자 필터링
  if (ownerProfileId) {
    baseQuery.eq("owner_profile_id", ownerProfileId);
  }

  // 정렬 처리
  if (sorting === "newest") {
    baseQuery.order("created_at", { ascending: false });
  } else if (sorting === "popular") {
    baseQuery.order("likes", { ascending: false });
  } else if (sorting === "trending") {
    baseQuery.order("views", { ascending: false });
  }

  // 기간 필터링
  if (period !== "all") {
    const today = DateTime.now();
    let startDate: DateTime;
    
    switch (period) {
      case "today":
        startDate = today.startOf("day");
        break;
      case "week":
        startDate = today.startOf("week");
        break;
      case "month":
        startDate = today.startOf("month");
        break;
      case "year":
        startDate = today.startOf("year");
        break;
    }
    
    baseQuery.gte("created_at", startDate.toISO());
  }

  // 키워드 검색
  if (keyword) {
    baseQuery.or(`title.ilike.%${keyword}%,description.ilike.%${keyword}%`);
  }

  // 상태 필터링
  if (status) {
    baseQuery.eq("status", status);
  }

  const { data, error } = await baseQuery;
  if (error) {
    console.error("프로젝트 조회 실패:", error);
    return [];
  }

  return data ?? [];
}
```

#### 3단계: Loader에 검증 추가

**파일: `app/features/projects/pages/project-list-page.tsx`**

```typescript
import { z } from "zod";

const searchParamsSchema = z.object({
  page: z.coerce.number().min(1).optional().default(1),
  sorting: z.enum(["newest", "popular", "trending"]).optional().default("newest"),
  period: z
    .enum(["all", "today", "week", "month", "year"])
    .optional()
    .default("all"),
  keyword: z.string().optional(),
  status: z.string().optional(),
});

export async function loader({ request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  const { success, data: parsedData } = searchParamsSchema.safeParse(
    Object.fromEntries(url.searchParams)
  );

  if (!success) {
    throw new Response("Invalid search parameters", { status: 400 });
  }

  const ownerProfileId = undefined; // TODO: 실제 사용자 인증 구현 후

  const [projects, totalPages] = await Promise.all([
    getProjects({
      ownerProfileId,
      page: parsedData.page,
      sorting: parsedData.sorting,
      period: parsedData.period,
      keyword: parsedData.keyword,
      status: parsedData.status,
    }),
    getProjectPages(ownerProfileId),
  ]);

  return {
    projects: projects ?? [],
    totalPages,
    currentPage: parsedData.page,
    filters: {
      sorting: parsedData.sorting,
      period: parsedData.period,
      keyword: parsedData.keyword,
      status: parsedData.status,
    },
  };
}
```

#### 4단계: UI에 필터링 컨트롤 추가

**필터링 UI 컴포넌트 예시:**

```typescript
export function ProjectFilters({
  sorting,
  period,
  keyword,
  status,
}: {
  sorting: string;
  period: string;
  keyword?: string;
  status?: string;
}) {
  const [searchParams, setSearchParams] = useSearchParams();

  const updateFilter = (key: string, value: string) => {
    const newParams = new URLSearchParams(searchParams);
    if (value) {
      newParams.set(key, value);
    } else {
      newParams.delete(key);
    }
    newParams.set("page", "1"); // 필터 변경 시 첫 페이지로
    setSearchParams(newParams, { preventScrollReset: true });
  };

  return (
    <div className="flex flex-wrap gap-4">
      {/* 정렬 선택 */}
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="outline">
            정렬: {sorting === "newest" ? "최신순" : sorting === "popular" ? "인기순" : "트렌딩"}
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          <DropdownMenuItem onClick={() => updateFilter("sorting", "newest")}>
            최신순
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => updateFilter("sorting", "popular")}>
            인기순
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => updateFilter("sorting", "trending")}>
            트렌딩
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      {/* 기간 필터 */}
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="outline">
            기간: {period === "all" ? "전체" : period === "today" ? "오늘" : period === "week" ? "이번 주" : period === "month" ? "이번 달" : "올해"}
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          <DropdownMenuItem onClick={() => updateFilter("period", "all")}>
            전체
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => updateFilter("period", "today")}>
            오늘
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => updateFilter("period", "week")}>
            이번 주
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => updateFilter("period", "month")}>
            이번 달
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => updateFilter("period", "year")}>
            올해
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      {/* 검색 */}
      <Form className="flex-1">
        <Input
          type="text"
          name="keyword"
          placeholder="프로젝트 검색..."
          defaultValue={keyword}
        />
      </Form>
    </div>
  );
}
```

## 장단점 비교

### 필터링 기능 추가의 장점

- ✅ 사용자 경험 향상: 원하는 프로젝트를 빠르게 찾을 수 있음
- ✅ 성능 최적화: 필요한 데이터만 조회하여 효율적
- ✅ 확장성: 새로운 필터 조건 추가가 용이
- ✅ 타입 안전성: Zod로 검증하여 런타임 에러 방지

### 주의사항

1. **인덱스 최적화**
   - 필터링에 사용되는 컬럼에 인덱스 추가 필요
   - `created_at`, `likes`, `views`, `title` 등

2. **View 성능**
   - 복잡한 JOIN이 포함된 View는 성능에 영향
   - 필요시 인덱스나 Materialized View 고려

3. **검색 성능**
   - `ilike`는 전체 텍스트 검색보다 느림
   - 대량 데이터의 경우 Full-Text Search 고려

4. **쿼리 파라미터 관리**
   - 필터가 많아질수록 URL이 길어짐
   - 중요한 필터만 URL에 포함하는 전략 필요

## 다음 단계

1. ✅ View 수정 (필요한 필드 추가)
2. ✅ 쿼리 함수에 필터링 옵션 추가
3. ✅ Loader에 Zod 검증 추가
4. ✅ UI에 필터링 컨트롤 추가
5. ⏳ 인덱스 최적화
6. ⏳ 성능 테스트 및 최적화

