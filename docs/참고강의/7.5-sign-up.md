# 7.5 Sign Up

## 커밋 요약

회원가입 및 로그인 기능을 완전히 구현한 커밋입니다. Zod를 사용한 폼 유효성 검사, Supabase 인증 통합, 사용자명 중복 확인, 그리고 로그아웃 기능을 포함합니다. 이전 커밋의 Action Function 패턴을 확장하여 실제 인증 로직을 구현했습니다.

## 주요 변경사항

### 1. 회원가입 페이지 (join-page.tsx)

#### Zod 스키마 정의

```typescript
const formSchema = z.object({
  name: z.string().min(3),
  username: z.string().min(3),
  email: z.string().email(),
  password: z.string().min(8),
});
```

**패턴**:
- Zod를 사용한 클라이언트/서버 양쪽 유효성 검사
- 필드별 최소 길이 및 형식 검증
- `safeParse`로 안전한 파싱

#### Action 함수 구현

```typescript
export const action = async ({ request }: Route.ActionArgs) => {
  const formData = await request.formData();
  const { success, error, data } = formSchema.safeParse(
    Object.fromEntries(formData)
  );

  // 유효성 검사 실패 시 필드별 에러 반환
  if (!success) {
    return {
      formErrors: error.flatten().fieldErrors,
    };
  }

  // 사용자명 중복 확인
  const usernameExists = await checkUsernameExists(request, {
    username: data.username,
  });

  if (usernameExists) {
    return {
      formErrors: { username: ["Username already exists"] },
    };
  }

  // Supabase 인증으로 회원가입
  const { client, headers } = makeSSRClient(request);
  const { error: signUpError } = await client.auth.signUp({
    email: data.email,
    password: data.password,
    options: {
      data: {
        name: data.name,
        username: data.username,
      },
    },
  });

  if (signUpError) {
    return {
      signUpError: signUpError.message,
    };
  }

  // 성공 시 홈으로 리다이렉트
  return redirect("/", { headers });
};
```

**패턴**:
- Zod `safeParse`로 유효성 검사
- `error.flatten().fieldErrors`로 필드별 에러 추출
- 사용자명 중복 확인 (별도 쿼리 함수)
- Supabase `signUp`으로 회원가입
- `options.data`로 추가 메타데이터 전달 (name, username)
- 성공 시 `redirect`와 `headers` 전달

#### UI에서 에러 표시

```typescript
export default function JoinPage({ actionData }: Route.ComponentProps) {
  const navigation = useNavigation();
  const isSubmitting =
    navigation.state === "submitting" || navigation.state === "loading";

  return (
    <Form className="w-full space-y-4" method="post">
      <InputPair id="name" ... />
      {actionData && "formErrors" in actionData && (
        <p className="text-red-500">{actionData?.formErrors?.name}</p>
      )}
      
      <InputPair id="username" ... />
      {actionData && "formErrors" in actionData && (
        <p className="text-red-500">{actionData?.formErrors?.username}</p>
      )}
      
      {/* ... */}
      
      <Button disabled={isSubmitting}>
        {isSubmitting ? (
          <LoaderCircle className="animate-spin" />
        ) : (
          "Create account"
        )}
      </Button>
      
      {actionData && "signUpError" in actionData && (
        <p className="text-red-500">{actionData.signUpError}</p>
      )}
    </Form>
  );
}
```

**패턴**:
- `actionData` 타입 가드로 안전하게 접근 (`"formErrors" in actionData`)
- 필드별 에러 메시지 표시
- 전체 에러 메시지 표시 (`signUpError`)
- 제출 중 상태 표시 (`isSubmitting`)

### 2. 로그인 페이지 (login-page.tsx)

#### Zod 스키마 정의

```typescript
const formSchema = z.object({
  email: z
    .string({
      required_error: "Email is required",
      invalid_type_error: "Email should be a string",
    })
    .email("Invalid email address"),
  password: z
    .string({
      required_error: "Password is required",
    })
    .min(8, {
      message: "Password must be at least 8 characters",
    }),
});
```

**패턴**:
- 커스텀 에러 메시지 정의
- 이메일 형식 검증
- 비밀번호 최소 길이 검증

#### Action 함수 구현

```typescript
export const action = async ({ request }: Route.ActionArgs) => {
  const formData = await request.formData();
  const { success, data, error } = formSchema.safeParse(
    Object.fromEntries(formData)
  );

  if (!success) {
    return {
      loginError: null,
      formErrors: error.flatten().fieldErrors,
    };
  }

  const { email, password } = data;
  const { client, headers } = makeSSRClient(request);
  const { error: loginError } = await client.auth.signInWithPassword({
    email,
    password,
  });

  if (loginError) {
    return {
      formErrors: null,
      loginError: loginError.message,
    };
  }

  return redirect("/", { headers });
};
```

**패턴**:
- Zod로 유효성 검사
- Supabase `signInWithPassword`로 로그인
- 필드 에러와 전체 에러를 구분하여 반환
- 성공 시 `redirect`와 `headers` 전달

#### UI에서 에러 표시

```typescript
{actionData && "formErrors" in actionData && (
  <p className="text-sm text-red-500">
    {actionData?.formErrors?.email?.join(", ")}
  </p>
)}

{actionData && "loginError" in actionData && (
  <p className="text-sm text-red-500">{actionData.loginError}</p>
)}
```

**패턴**:
- 필드별 에러는 배열로 반환되므로 `join(", ")`로 표시
- 전체 에러는 단일 메시지로 표시

### 3. 로그아웃 페이지 (logout-page.tsx)

```typescript
import { makeSSRClient } from "~/supa-client";
import { Route } from "./+types/logout-page";
import { redirect } from "react-router";

export const loader = async ({ request }: Route.LoaderArgs) => {
  const { client, headers } = makeSSRClient(request);
  await client.auth.signOut();
  return redirect("/", { headers });
};
```

**패턴**:
- `loader`에서 로그아웃 처리 (GET 요청)
- Supabase `signOut`으로 세션 종료
- `headers`를 전달하여 쿠키 업데이트
- 홈으로 리다이렉트

**장점**:
- 간단한 로그아웃 플로우
- 쿠키 기반 세션 관리
- GET 요청으로 처리 가능

### 4. 사용자명 중복 확인 쿼리 (queries.ts)

```typescript
import { makeSSRClient } from "~/supa-client";

export const checkUsernameExists = async (
  request: Request,
  { username }: { username: string }
) => {
  const { client } = makeSSRClient(request);
  const { error } = await client
    .from("profiles")
    .select("profile_id")
    .eq("username", username)
    .single();

  if (error) {
    return false; // 에러 발생 시 사용자명이 존재하지 않음
  }

  return true; // 데이터가 있으면 사용자명이 존재함
};
```

**패턴**:
- `makeSSRClient`로 서버 사이드 클라이언트 생성
- `profiles` 테이블에서 `username`으로 조회
- `.single()`로 단일 결과만 반환
- 에러 발생 시 `false` 반환 (사용자명 없음)
- 데이터 존재 시 `true` 반환 (사용자명 있음)

**장점**:
- 서버 사이드에서 중복 확인
- 쿼리 함수로 재사용 가능
- 에러 처리 간단

### 5. 라우팅 추가 (routes.ts)

```typescript
route("/logout", "features/auth/pages/logout-page.tsx"),
```

**패턴**:
- 간단한 라우트 정의
- GET 요청으로 로그아웃 처리

## 적용 패턴

### 1. Zod를 사용한 유효성 검사

```typescript
const formSchema = z.object({
  field1: z.string().min(3),
  field2: z.string().email(),
  field3: z.string().min(8),
});

const { success, data, error } = formSchema.safeParse(
  Object.fromEntries(formData)
);

if (!success) {
  return {
    formErrors: error.flatten().fieldErrors,
  };
}
```

**장점**:
- 클라이언트/서버 양쪽에서 동일한 검증 로직
- 타입 안정성
- 상세한 에러 메시지

### 2. Supabase 인증 통합

```typescript
// 회원가입
const { error: signUpError } = await client.auth.signUp({
  email: data.email,
  password: data.password,
  options: {
    data: {
      name: data.name,
      username: data.username,
    },
  },
});

// 로그인
const { error: loginError } = await client.auth.signInWithPassword({
  email,
  password,
});

// 로그아웃
await client.auth.signOut();
```

**패턴**:
- `makeSSRClient`로 서버 사이드 클라이언트 생성
- `headers`를 반환하여 쿠키 업데이트
- `redirect`와 함께 `headers` 전달

### 3. 에러 처리 패턴

```typescript
// 필드별 에러
if (!success) {
  return {
    formErrors: error.flatten().fieldErrors,
  };
}

// 전체 에러
if (signUpError) {
  return {
    signUpError: signUpError.message,
  };
}
```

**UI에서 표시**:
```typescript
{actionData && "formErrors" in actionData && (
  <p className="text-red-500">
    {actionData?.formErrors?.fieldName?.join(", ")}
  </p>
)}

{actionData && "signUpError" in actionData && (
  <p className="text-red-500">{actionData.signUpError}</p>
)}
```

### 4. 사용자명 중복 확인 패턴

```typescript
const usernameExists = await checkUsernameExists(request, {
  username: data.username,
});

if (usernameExists) {
  return {
    formErrors: { username: ["Username already exists"] },
  };
}
```

**장점**:
- 서버 사이드에서 중복 확인
- 쿼리 함수로 재사용 가능
- 에러를 `formErrors`로 통합

## 장점

1. **타입 안정성**: Zod로 런타임 검증 및 타입 추론
2. **에러 처리**: 필드별 및 전체 에러 구분
3. **사용자 경험**: 제출 중 상태 표시 및 명확한 에러 메시지
4. **보안**: 서버 사이드에서 유효성 검사 및 인증 처리
5. **재사용성**: 쿼리 함수로 중복 확인 로직 분리

## 주의사항

1. **쿠키 관리**: `makeSSRClient`의 `headers`를 `redirect`에 전달해야 쿠키가 업데이트됨
2. **에러 타입**: `actionData`의 타입을 안전하게 확인하기 위해 타입 가드 사용
3. **비밀번호 정책**: 최소 길이 외에도 복잡도 요구사항 고려
4. **사용자명 정책**: 중복 확인 외에도 사용 가능한 문자 제한 고려
5. **이메일 인증**: Supabase는 기본적으로 이메일 인증을 요구할 수 있음

## 마이그레이션 순서

1. Zod 스키마 정의
2. Action 함수에 유효성 검사 추가
3. 사용자명 중복 확인 쿼리 함수 추가
4. Supabase 인증 통합
5. UI에 에러 메시지 표시 추가
6. 로그아웃 페이지 및 라우트 추가

## 참고

- Zod는 클라이언트/서버 양쪽에서 동일한 검증 로직 사용 가능
- Supabase 인증은 쿠키 기반 세션 관리
- `makeSSRClient`의 `headers`를 `redirect`에 전달해야 쿠키 업데이트
- 필드별 에러는 배열로 반환되므로 `join(", ")`로 표시
- 전체 에러는 단일 메시지로 표시

