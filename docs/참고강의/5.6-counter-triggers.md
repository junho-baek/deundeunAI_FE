# 5.6 Counter Triggers

## 커밋 개요

이 커밋은 데이터베이스 트리거를 사용하여 카운터 필드를 자동으로 관리하는 패턴을 구현합니다. `post_upvotes` 테이블에 레코드가 추가되거나 삭제될 때마다 `posts` 테이블의 `upvotes` 카운터가 자동으로 증가/감소되도록 트리거 함수를 생성합니다.

## 주요 변경사항

### 1. 스키마에 카운터 필드 추가

**변경된 파일: `app/features/community/schema.ts`**

```typescript
export const posts = pgTable("posts", {
  post_id: bigint({ mode: "number" }).primaryKey().generatedAlwaysAsIdentity(),
  title: text().notNull(),
  content: text().notNull(),
  upvotes: bigint({ mode: "number" }).default(0),  // 새로 추가된 카운터 필드
  created_at: timestamp().notNull().defaultNow(),
  updated_at: timestamp().notNull().defaultNow(),
  topic_id: bigint({ mode: "number" }).references(() => topics.topic_id, {
    // ...
  }),
  // ...
});
```

**핵심 포인트:**

- `upvotes` 필드를 `bigint` 타입으로 추가
- 기본값을 `0`으로 설정
- 카운터는 별도 테이블(`post_upvotes`)의 레코드 수를 반영

### 2. 마이그레이션 파일 생성

**새로 생성된 파일: `app/sql/migrations/0008_modern_cannonball.sql`**

```sql
ALTER TABLE "posts" ADD COLUMN "upvotes" bigint DEFAULT 0;
```

**핵심 포인트:**

- 기존 테이블에 카운터 컬럼 추가
- 기본값 설정으로 기존 레코드도 0으로 초기화
- 마이그레이션을 통해 안전하게 스키마 변경

### 3. 트리거 함수 생성

**새로 생성된 파일: `app/sql/triggers/post-upvote-trigger.sql`**

#### Upvote 트리거 함수

```sql
CREATE FUNCTION public.handle_post_upvote()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    UPDATE public.posts SET upvotes = upvotes + 1 WHERE post_id = NEW.post_id;
    RETURN NEW;
END;
$$;

CREATE TRIGGER post_upvote_trigger
AFTER INSERT ON public.post_upvotes
FOR EACH ROW EXECUTE FUNCTION public.handle_post_upvote();
```

**핵심 포인트:**

- `handle_post_upvote()`: `post_upvotes` 테이블에 INSERT 시 실행되는 함수
- `NEW.post_id`를 사용하여 해당 포스트의 `upvotes`를 1 증가
- `SECURITY DEFINER`: 함수 실행 시 함수 소유자의 권한 사용
- `SET search_path = ''`: SQL injection 방지

#### Unvote 트리거 함수

```sql
CREATE FUNCTION public.handle_post_unvote()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    UPDATE public.posts SET upvotes = upvotes - 1 WHERE post_id = OLD.post_id;
    RETURN OLD;
END;
$$;

CREATE TRIGGER post_unvote_trigger
AFTER DELETE ON public.post_upvotes
FOR EACH ROW EXECUTE FUNCTION public.handle_post_unvote();
```

**핵심 포인트:**

- `handle_post_unvote()`: `post_upvotes` 테이블에서 DELETE 시 실행되는 함수
- `OLD.post_id`를 사용하여 해당 포스트의 `upvotes`를 1 감소
- 트리거는 `AFTER DELETE`로 설정되어 레코드 삭제 후 실행

## 우리 프로젝트에 적용하기

### 현재 상태 분석

우리 프로젝트는 현재:

- ✅ Drizzle ORM 스키마 사용 중
- ✅ 마이그레이션 시스템 구축됨
- ✅ Supabase 데이터베이스 사용 중
- ❌ 카운터 트리거 미구현
- ❌ 카운터 필드가 있는 테이블 존재 (예: `projects.likes`, `projects.views`)

### 적용 전략

#### 1단계: 카운터가 필요한 테이블 식별

**카운터 트리거가 유용한 경우:**

1. **관계 테이블의 레코드 수를 메인 테이블에 저장**
   - 예: `project_likes` → `projects.likes`
   - 예: `project_views` → `projects.views`
   - 예: `profile_follows` → `profiles.followers_count`

2. **빈번한 집계 쿼리 최적화**
   - `COUNT(*)` 쿼리 대신 저장된 카운터 사용
   - 성능 향상 및 쿼리 단순화

3. **실시간 카운터가 필요한 경우**
   - 사용자에게 즉시 표시되어야 하는 카운터
   - 예: 좋아요 수, 조회수, 팔로워 수

#### 2단계: 스키마에 카운터 필드 추가

**예시: 프로젝트 좋아요 카운터**

```typescript
// app/features/projects/schema.ts
export const projects = pgTable("projects", {
  project_id: uuid("project_id").primaryKey().defaultRandom(),
  title: text("title").notNull(),
  // ... 기존 필드들
  likes: integer("likes").default(0).notNull(),  // 카운터 필드 추가
  views: integer("views").default(0).notNull(),  // 카운터 필드 추가
  // ...
});
```

**주의사항:**

- 카운터 필드는 `NOT NULL`로 설정하고 기본값 `0` 제공
- 기존 레코드가 있으면 마이그레이션에서 초기값 설정 필요

#### 3단계: 마이그레이션 파일 생성

**파일: `app/sql/migrations/XXXX_add_project_counters.sql`**

```sql
-- 카운터 필드 추가
ALTER TABLE "projects" ADD COLUMN "likes" integer DEFAULT 0 NOT NULL;
ALTER TABLE "projects" ADD COLUMN "views" integer DEFAULT 0 NOT NULL;

-- 기존 데이터의 카운터 초기화 (선택사항)
UPDATE "projects" 
SET 
  "likes" = (SELECT COUNT(*) FROM "project_likes" WHERE "project_likes"."project_id" = "projects"."project_id"),
  "views" = (SELECT COUNT(*) FROM "project_views" WHERE "project_views"."project_id" = "projects"."project_id");
```

#### 4단계: 트리거 함수 및 트리거 생성

**파일: `app/sql/triggers/project-like-trigger.sql`**

```sql
-- 좋아요 추가 트리거 함수
CREATE FUNCTION public.handle_project_like()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    UPDATE public.projects 
    SET likes = likes + 1 
    WHERE project_id = NEW.project_id;
    RETURN NEW;
END;
$$;

-- 좋아요 추가 트리거
CREATE TRIGGER project_like_trigger
AFTER INSERT ON public.project_likes
FOR EACH ROW EXECUTE FUNCTION public.handle_project_like();

-- 좋아요 제거 트리거 함수
CREATE FUNCTION public.handle_project_unlike()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    UPDATE public.projects 
    SET likes = likes - 1 
    WHERE project_id = OLD.project_id;
    RETURN OLD;
END;
$$;

-- 좋아요 제거 트리거
CREATE TRIGGER project_unlike_trigger
AFTER DELETE ON public.project_likes
FOR EACH ROW EXECUTE FUNCTION public.handle_project_unlike();
```

**파일: `app/sql/triggers/project-view-trigger.sql`**

```sql
-- 조회수 증가 트리거 함수 (INSERT만, DELETE 없음)
CREATE FUNCTION public.handle_project_view()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    UPDATE public.projects 
    SET views = views + 1 
    WHERE project_id = NEW.project_id;
    RETURN NEW;
END;
$$;

-- 조회수 증가 트리거
CREATE TRIGGER project_view_trigger
AFTER INSERT ON public.project_views
FOR EACH ROW EXECUTE FUNCTION public.handle_project_view();
```

#### 5단계: 트리거 실행 (Supabase 대시보드 또는 마이그레이션)

**방법 1: Supabase 대시보드에서 실행**

1. Supabase 대시보드 접속
2. SQL Editor 열기
3. 트리거 SQL 파일 내용 복사하여 실행

**방법 2: 마이그레이션 파일에 포함**

```sql
-- app/sql/migrations/XXXX_add_project_counters.sql
-- ... 카운터 필드 추가 SQL ...

-- 트리거 함수 및 트리거 생성
\i app/sql/triggers/project-like-trigger.sql
\i app/sql/triggers/project-view-trigger.sql
```

**방법 3: Drizzle 마이그레이션에 직접 포함**

```typescript
// app/sql/migrations/XXXX_add_project_counters.sql
-- 카운터 필드 추가
ALTER TABLE "projects" ADD COLUMN "likes" integer DEFAULT 0 NOT NULL;

-- 트리거 함수 생성
CREATE FUNCTION public.handle_project_like()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    UPDATE public.projects 
    SET likes = likes + 1 
    WHERE project_id = NEW.project_id;
    RETURN NEW;
END;
$$;

-- 트리거 생성
CREATE TRIGGER project_like_trigger
AFTER INSERT ON public.project_likes
FOR EACH ROW EXECUTE FUNCTION public.handle_project_like();
```

#### 6단계: 쿼리 함수 업데이트

**Before (COUNT 쿼리 사용):**

```typescript
// app/features/projects/queries.ts
export async function getProjectLikes(projectId: string) {
  const { count, error } = await client
    .from("project_likes")
    .select("*", { count: "exact", head: true })
    .eq("project_id", projectId);

  return count ?? 0;
}
```

**After (카운터 필드 사용):**

```typescript
// app/features/projects/queries.ts
export async function getProjectLikes(projectId: string) {
  const { data, error } = await client
    .from("projects")
    .select("likes")
    .eq("project_id", projectId)
    .single();

  return data?.likes ?? 0;
}
```

**장점:**

- 쿼리 성능 향상 (COUNT 대신 단순 SELECT)
- 코드 단순화
- View에서도 카운터 필드 직접 사용 가능

## 트리거 패턴 설명

### 기본 패턴

```sql
-- 1. 트리거 함수 생성
CREATE FUNCTION public.handle_[action]()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    UPDATE [main_table] 
    SET [counter_field] = [counter_field] + 1  -- 또는 -1
    WHERE [id_field] = NEW.[id_field];  -- INSERT의 경우
    -- WHERE [id_field] = OLD.[id_field];  -- DELETE의 경우
    RETURN NEW;  -- 또는 OLD
END;
$$;

-- 2. 트리거 생성
CREATE TRIGGER [action]_trigger
AFTER INSERT ON [relation_table]  -- 또는 AFTER DELETE
FOR EACH ROW EXECUTE FUNCTION public.handle_[action]();
```

### 다양한 패턴

#### 1. 단방향 카운터 (증가만)

```sql
-- 조회수처럼 감소가 없는 경우
CREATE FUNCTION public.handle_view()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    UPDATE public.projects 
    SET views = views + 1 
    WHERE project_id = NEW.project_id;
    RETURN NEW;
END;
$$;

CREATE TRIGGER view_trigger
AFTER INSERT ON public.project_views
FOR EACH ROW EXECUTE FUNCTION public.handle_view();
```

#### 2. 양방향 카운터 (증가/감소)

```sql
-- 좋아요처럼 추가/제거가 모두 있는 경우
-- INSERT 트리거 (위에서 설명)
-- DELETE 트리거 (위에서 설명)
```

#### 3. 조건부 카운터

```sql
CREATE FUNCTION public.handle_conditional_like()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    -- 특정 조건에서만 카운터 증가
    IF NEW.is_active = true THEN
        UPDATE public.projects 
        SET likes = likes + 1 
        WHERE project_id = NEW.project_id;
    END IF;
    RETURN NEW;
END;
$$;
```

## 장단점 비교

### 트리거 사용 장점

- ✅ **성능 향상**: COUNT 쿼리 대신 단순 SELECT 사용
- ✅ **데이터 일관성**: 애플리케이션 레벨에서 실수로 카운터를 업데이트하지 않아도 자동 관리
- ✅ **코드 단순화**: 카운터 업데이트 로직이 데이터베이스에 캡슐화
- ✅ **트랜잭션 안전성**: 관계 테이블 변경과 카운터 업데이트가 원자적으로 처리

### 트리거 사용 단점

- ❌ **디버깅 어려움**: 트리거는 숨겨진 로직이므로 문제 발생 시 추적이 어려울 수 있음
- ❌ **복잡성 증가**: 데이터베이스 로직이 애플리케이션 코드와 분리됨
- ❌ **테스트 어려움**: 트리거는 데이터베이스에서 직접 테스트해야 함
- ❌ **마이그레이션 복잡도**: 트리거 관리가 추가로 필요

### 언제 트리거를 사용해야 할까?

**트리거 사용 권장:**

- 카운터가 자주 조회되는 경우 (성능 최적화)
- 카운터 업데이트가 여러 곳에서 발생하는 경우 (일관성 보장)
- 실시간 카운터가 중요한 경우
- COUNT 쿼리가 성능 병목인 경우

**트리거 사용 비권장:**

- 카운터가 거의 조회되지 않는 경우 (오버엔지니어링)
- 카운터 업데이트가 단일 지점에서만 발생하는 경우
- 간단한 프로젝트에서 복잡도 증가를 원하지 않는 경우

## 주의사항

1. **트리거 함수 보안**
   - `SECURITY DEFINER` 사용 시 함수 소유자 권한으로 실행됨
   - `SET search_path = ''`로 SQL injection 방지
   - 함수 내부에서 입력값 검증 필요

2. **카운터 동기화**
   - 기존 데이터가 있으면 마이그레이션에서 초기화 필요
   - 트리거 생성 전에 카운터를 수동으로 동기화할 수 있음

3. **트랜잭션 처리**
   - 트리거는 트랜잭션 내에서 실행됨
   - 관계 테이블 변경이 롤백되면 카운터도 롤백됨

4. **성능 고려**
   - 트리거는 각 행마다 실행되므로 대량 삽입 시 성능 영향 가능
   - 필요시 배치 처리 고려

5. **트리거 관리**
   - 트리거 함수와 트리거를 버전 관리에 포함
   - 마이그레이션 파일에 트리거 생성/삭제 로직 포함

## 다음 단계

1. ✅ 트리거 개념 이해
2. ✅ 카운터가 필요한 테이블 식별
3. ⏳ 스키마에 카운터 필드 추가
4. ⏳ 트리거 함수 및 트리거 생성
5. ⏳ 마이그레이션 실행
6. ⏳ 쿼리 함수 업데이트
7. ⏳ 테스트 및 검증

## 참고 자료

- [PostgreSQL 트리거 문서](https://www.postgresql.org/docs/current/triggers.html)
- [PostgreSQL 함수 문서](https://www.postgresql.org/docs/current/sql-createfunction.html)
- [Supabase 트리거 가이드](https://supabase.com/docs/guides/database/triggers)

