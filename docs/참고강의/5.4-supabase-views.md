# 5.4 Supabase Views

## 커밋 개요

이 커밋은 복잡한 JOIN 쿼리를 Supabase View로 추상화하여 쿼리 코드를 단순화하고, 데이터 구조를 평탄화하는 작업을 포함합니다. View를 사용하면 복잡한 관계 쿼리를 간단한 테이블 조회처럼 사용할 수 있습니다.

## 주요 변경사항

### 1. SQL View 생성

**새로 생성된 파일: `app/sql/views/community-post-list-view.sql`**

```sql
CREATE VIEW community_post_list_view AS
SELECT
  posts.post_id,
  posts.title,
  posts.created_at,
  topics.name AS topic,
  profiles.name AS author,
  profiles.avatar AS author_avatar,
  profiles.username AS author_username,
  COUNT(post_upvotes.post_id) AS upvotes
FROM posts
INNER JOIN topics USING (topic_id)
INNER JOIN profiles USING (profile_id)
LEFT JOIN post_upvotes USING (post_id)
GROUP BY posts.post_id, topics.name, profiles.name, profiles.avatar, profiles.username;
```

**핵심 포인트:**

- 복잡한 JOIN과 집계 함수를 View로 캡슐화
- 평탄화된 데이터 구조 제공 (중첩 객체 없음)
- 재사용 가능한 쿼리 뷰 생성
- `COUNT()` 집계 함수를 View에서 처리

### 2. 쿼리 함수 단순화

**Before (복잡한 관계 쿼리):**

```typescript
export const getPosts = async () => {
  const { data, error } = await client.from("posts").select(`
    post_id,
    title,
    created_at,
    topic:topics!inner (
      name
    ),
    author:profiles!posts_profile_id_profiles_profile_id_fk!inner (
      name,
      username,
      avatar
    ),
    upvotes:post_upvotes (
      count
    )
  `);

  if (error) throw new Error(error.message);
  return data;
};
```

**After (View 사용):**

```typescript
export const getPosts = async () => {
  const { data, error } = await client
    .from("community_post_list_view")
    .select(`*`);

  if (error) throw new Error(error.message);
  return data;
};
```

**주요 차이점:**

- 복잡한 관계 쿼리 구문 제거
- 간단한 `select('*')` 사용 가능
- 코드 가독성 향상
- 유지보수 용이성 증가

### 3. 데이터 구조 변경

**Before (중첩 객체 구조):**

```typescript
{
  post_id: number,
  title: string,
  created_at: string,
  topic: {
    name: string
  },
  author: {
    name: string,
    username: string,
    avatar: string
  },
  upvotes: [
    { count: number }
  ]
}
```

**After (평탄화된 구조):**

```typescript
{
  post_id: number,
  title: string,
  created_at: string,
  topic: string,              // 평탄화됨
  author: string,            // 평탄화됨
  author_avatar: string,     // 평탄화됨
  author_username: string,    // 평탄화됨
  upvotes: number            // 평탄화됨 (COUNT 결과)
}
```

**컴포넌트에서의 변경:**

```typescript
// Before
<PostCard
  id={post.post_id}
  title={post.title}
  author={post.author.name}              // 중첩 객체 접근
  authorAvatarUrl={post.author.avatar}   // 중첩 객체 접근
  category={post.topic.name}             // 중첩 객체 접근
  postedAt={post.created_at}
  votesCount={post.upvotes[0].count}    // 배열 접근
/>

// After
<PostCard
  id={post.post_id!}
  title={post.title!}
  author={post.author!}                 // 평탄화된 필드
  authorAvatarUrl={post.author_avatar}  // 평탄화된 필드
  category={post.topic!}                 // 평탄화된 필드
  postedAt={post.created_at!}
  votesCount={post.upvotes!}             // 평탄화된 필드
/>
```

**변경 이유:**

- View가 JOIN 결과를 평탄화하여 반환
- 중첩 객체 접근 불필요
- 배열 인덱스 접근 불필요
- 타입 안전성 향상 (null 체크 필요)

### 4. Database Types 업데이트

**database.types.ts에 View 타입 추가:**

```typescript
Views: {
  community_post_list_view: {
    Row: {
      author: string | null
      author_avatar: string | null
      author_username: string | null
      created_at: string | null
      post_id: number | null
      title: string | null
      topic: string | null
      upvotes: number | null
    }
    Relationships: []
  }
}
```

**타입 생성:**

- Supabase CLI가 View를 자동으로 인식하여 타입 생성
- `db:typegen` 실행 시 View 타입 포함
- View는 Relationships가 없음 (이미 JOIN된 결과)

## 우리 프로젝트에 적용하기

### 현재 상태 분석

우리 프로젝트는 현재:

- ✅ Supabase 클라이언트 설정 완료
- ✅ 복잡한 관계 쿼리 사용 중 (projects, dashboard 등)
- ❌ View 미사용
- ❌ SQL View 파일 없음

### 적용 전략

#### 1단계: View 생성 전략 수립

**View를 사용하면 좋은 경우:**

1. **복잡한 JOIN이 반복되는 경우**
   - 여러 쿼리에서 동일한 JOIN 패턴 사용
   - 예: 프로젝트 + 프로필 + 메트릭스 조회

2. **집계 함수가 필요한 경우**
   - COUNT, SUM, AVG 등 집계 결과가 자주 필요
   - 예: 프로젝트별 좋아요 수, 평균 CTR

3. **데이터 구조를 평탄화하고 싶은 경우**
   - 중첩 객체 대신 평탄화된 구조 선호
   - 컴포넌트에서 접근이 더 간단해짐

4. **성능 최적화가 필요한 경우**
   - View는 데이터베이스 레벨에서 최적화 가능
   - 인덱스 활용 가능

#### 2단계: SQL View 파일 생성

**파일 구조:**

```
app/
  sql/
    views/
      project-list-view.sql
      dashboard-stats-view.sql
      ...
```

**View 생성 예시 (프로젝트 목록):**

```sql
-- app/sql/views/project-list-view.sql
CREATE VIEW project_list_view AS
SELECT
  projects.project_id,
  projects.title,
  projects.description,
  projects.thumbnail,
  projects.likes,
  projects.ctr,
  projects.budget,
  projects.created_at,
  profiles.name AS owner_name,
  profiles.avatar AS owner_avatar,
  COUNT(project_metrics.metric_id) AS metrics_count
FROM projects
LEFT JOIN profiles ON projects.owner_profile_id = profiles.profile_id
LEFT JOIN project_metrics ON projects.project_id = project_metrics.project_id
GROUP BY 
  projects.project_id, 
  profiles.name, 
  profiles.avatar;
```

#### 3단계: 마이그레이션에 View 추가

**Drizzle 마이그레이션 파일에 View 추가:**

```typescript
// app/migrations/XXXX_add_project_list_view.sql
CREATE VIEW project_list_view AS
SELECT
  projects.project_id,
  projects.title,
  -- ... (위의 SQL 내용)
```

**또는 Supabase 대시보드에서 직접 생성:**

1. Supabase 대시보드 접속
2. SQL Editor 열기
3. View 생성 SQL 실행
4. `db:typegen` 실행하여 타입 업데이트

#### 4단계: 쿼리 함수 전환

**Before (복잡한 관계 쿼리):**

```typescript
// app/features/projects/queries.ts
export async function getProjects() {
  const { data, error } = await client
    .from("projects")
    .select(`
      project_id,
      title,
      description,
      owner:profiles!projects_owner_profile_id_profiles_profile_id_fk (
        name,
        avatar
      ),
      metrics:project_metrics (
        metric_id
      )
    `);

  if (error) throw new Error(error.message);
  return data;
}
```

**After (View 사용):**

```typescript
// app/features/projects/queries.ts
export async function getProjects() {
  const { data, error } = await client
    .from("project_list_view")
    .select("*");

  if (error) throw new Error(error.message);
  return data;
}
```

#### 5단계: 컴포넌트 업데이트

**Before:**

```typescript
<ProjectCard
  title={project.title}
  owner={project.owner.name}
  ownerAvatar={project.owner.avatar}
  metricsCount={project.metrics.length}
/>
```

**After:**

```typescript
<ProjectCard
  title={project.title!}
  owner={project.owner_name!}
  ownerAvatar={project.owner_avatar}
  metricsCount={project.metrics_count!}
/>
```

#### 6단계: 타입 업데이트

**Database Types 재생성:**

```bash
npm run db:typegen
```

**타입 확인:**

```typescript
// database.types.ts에 View 타입이 추가되었는지 확인
Views: {
  project_list_view: {
    Row: {
      project_id: string | null
      title: string | null
      owner_name: string | null
      // ...
    }
  }
}
```

## View 사용 패턴

### 1. 읽기 전용 쿼리

View는 기본적으로 읽기 전용입니다. INSERT, UPDATE, DELETE는 원본 테이블에서 수행해야 합니다.

```typescript
// ✅ 가능: SELECT
const { data } = await client.from("project_list_view").select("*");

// ❌ 불가능: INSERT, UPDATE, DELETE
// View는 읽기 전용이므로 원본 테이블 사용
const { data } = await client.from("projects").insert({ ... });
```

### 2. 필터링 및 정렬

View도 일반 테이블처럼 필터링과 정렬이 가능합니다.

```typescript
const { data } = await client
  .from("project_list_view")
  .select("*")
  .eq("owner_name", "John")
  .order("created_at", { ascending: false })
  .limit(10);
```

### 3. 집계 함수 활용

View에서 이미 집계된 데이터를 활용할 수 있습니다.

```typescript
// View에서 COUNT 결과를 바로 사용
const { data } = await client
  .from("project_list_view")
  .select("metrics_count")
  .gt("metrics_count", 5); // 집계 결과로 필터링
```

## 장단점 비교

### View 사용 장점

- ✅ **코드 단순화**: 복잡한 JOIN 쿼리 제거
- ✅ **재사용성**: 여러 곳에서 동일한 View 사용 가능
- ✅ **성능 최적화**: 데이터베이스 레벨 최적화 가능
- ✅ **데이터 구조 평탄화**: 중첩 객체 없이 간단한 접근
- ✅ **유지보수 용이**: View만 수정하면 모든 쿼리 반영

### View 사용 단점

- ❌ **읽기 전용**: INSERT, UPDATE, DELETE 불가
- ❌ **타입 생성 필요**: View 변경 시 타입 재생성 필요
- ❌ **마이그레이션 관리**: View SQL 파일 관리 필요
- ❌ **유연성 제한**: 동적 쿼리 구성이 어려울 수 있음

### 언제 View를 사용해야 할까?

**View 사용 권장:**

- 복잡한 JOIN이 반복되는 경우
- 집계 함수가 자주 필요한 경우
- 데이터 구조를 평탄화하고 싶은 경우
- 읽기 전용 쿼리인 경우

**View 사용 비권장:**

- 동적 쿼리가 필요한 경우
- INSERT/UPDATE/DELETE가 필요한 경우
- 간단한 쿼리인 경우 (오버엔지니어링)

## 주의사항

1. **View 타입 동기화**
   - View 변경 시 `db:typegen` 재실행 필수
   - CI/CD 파이프라인에 타입 생성 단계 추가 고려

2. **마이그레이션 관리**
   - View SQL 파일을 버전 관리에 포함
   - Drizzle 마이그레이션에 View 생성 SQL 추가

3. **성능 고려**
   - View는 실제로 쿼리 실행 시 JOIN 수행
   - 인덱스가 적절히 설정되어 있는지 확인

4. **Null 처리**
   - View의 필드는 `null` 가능성이 있음
   - 컴포넌트에서 null 체크 필요 (`post.title!` 또는 옵셔널 체이닝)

5. **View 이름 규칙**
   - 명확하고 일관된 네이밍 사용
   - 예: `{feature}_{purpose}_view` (예: `project_list_view`)

## 다음 단계

1. ✅ View 개념 이해
2. ✅ SQL View 파일 생성 방법 학습
3. ⏳ 프로젝트에 적용할 View 식별
4. ⏳ View SQL 파일 생성
5. ⏳ 쿼리 함수 전환
6. ⏳ 컴포넌트 업데이트
7. ⏳ 타입 재생성 및 테스트

## 참고 자료

- [Supabase Views 문서](https://supabase.com/docs/guides/database/views)
- [PostgreSQL Views 가이드](https://www.postgresql.org/docs/current/sql-createview.html)
- [Supabase TypeScript 타입 생성](https://supabase.com/docs/reference/javascript/typescript-support)

