# 6.7 Categories Pages

## 커밋 개요

이 커밋은 Categories 기능을 구현하고 실제 DB 데이터를 사용하도록 개선합니다. 공통 select 쿼리 추출, 카테고리별 제품 필터링, 페이지네이션을 구현합니다.

## 주요 변경사항

### 1. 공통 Select 쿼리 추출

**변경된 파일: `app/features/products/queries.ts`**

**Before:**
```typescript
export const getProductsByDateRange = async ({...}) => {
  const { data, error } = await client
    .from("products")
    .select(`
      product_id,
      name,
      description,
      upvotes:stats->>upvotes,
      views:stats->>views,
      reviews:stats->>reviews
    `)
    // ...
};
```

**After:**
```typescript
const productListSelect = `
  product_id,
  name,
  description,
  upvotes:stats->>upvotes,
  views:stats->>views,
  reviews:stats->>reviews
`;

export const getProductsByDateRange = async ({...}) => {
  const { data, error } = await client
    .from("products")
    .select(productListSelect)
    // ...
};
```

**핵심 포인트:**
- **중복 제거**: 반복되는 select 쿼리를 상수로 추출
- **유지보수성**: 필드 변경 시 한 곳만 수정하면 됨
- **일관성**: 모든 제품 목록 쿼리에서 동일한 필드 사용

### 2. 카테고리 쿼리 함수 생성

**변경된 파일: `app/features/products/queries.ts`**

```typescript
export const getCategories = async () => {
  const { data, error } = await client
    .from("categories")
    .select("category_id, name, description");
  
  if (error) throw error;
  return data;
};

export const getCategory = async (categoryId: number) => {
  const { data, error } = await client
    .from("categories")
    .select("category_id, name, description")
    .eq("category_id", categoryId)
    .single();
  
  if (error) throw error;
  return data;
};

export const getProductsByCategory = async ({
  categoryId,
  page,
}: {
  categoryId: number;
  page: number;
}) => {
  const { data, error } = await client
    .from("products")
    .select(productListSelect)
    .eq("category_id", categoryId)
    .range((page - 1) * PAGE_SIZE, page * PAGE_SIZE - 1);
  
  if (error) throw error;
  return data;
};

export const getCategoryPages = async (categoryId: number) => {
  const { count, error } = await client
    .from("products")
    .select(`product_id`, { count: "exact", head: true })
    .eq("category_id", categoryId);
  
  if (error) throw error;
  if (!count) return 1;
  return Math.ceil(count / PAGE_SIZE);
};
```

**핵심 포인트:**
- **카테고리 목록 조회**: `getCategories()`로 모든 카테고리 조회
- **단일 카테고리 조회**: `getCategory()`로 특정 카테고리 정보 조회
- **카테고리별 제품 조회**: `getProductsByCategory()`로 필터링된 제품 목록 조회
- **페이지 수 계산**: `getCategoryPages()`로 카테고리별 총 페이지 수 계산

### 3. Categories 페이지 구현

**변경된 파일: `app/features/products/pages/categories-page.tsx`**

**Before:**
```typescript
export default function CategoriesPage() {
  return (
    <div>
      <Hero title="Categories" subtitle="Browse products by category" />
      <div>
        {Array.from({ length: 10 }).map((_, index) => (
          <CategoryCard
            key={`categoryId-${index}`}
            id={`categoryId-${index}`}
            name="Category Name"
            description="Category Description"
          />
        ))}
      </div>
    </div>
  );
}
```

**After:**
```typescript
import { getCategories } from "../queries";

export const loader = async () => {
  const categories = await getCategories();
  return { categories };
};

export default function CategoriesPage({ loaderData }: Route.ComponentProps) {
  return (
    <div>
      <Hero title="Categories" subtitle="Browse products by category" />
      <div>
        {loaderData.categories.map((category) => (
          <CategoryCard
            key={category.category_id}
            id={category.category_id}
            name={category.name}
            description={category.description}
          />
        ))}
      </div>
    </div>
  );
}
```

**핵심 포인트:**
- Loader로 서버 사이드 데이터 로드
- 실제 DB 데이터 사용

### 4. Category 페이지 구현 (카테고리별 제품 목록)

**변경된 파일: `app/features/products/pages/category-page.tsx`**

**Before:**
```typescript
export default function CategoryPage() {
  return (
    <div>
      <Hero title={"Developer Tools"} subtitle={`Tools for developers...`} />
      <div>
        {Array.from({ length: 11 }).map((_, index) => (
          <ProductCard
            key={`productId-${index}`}
            id={`productId-${index}`}
            name="Product Name"
            // ...
          />
        ))}
      </div>
      <ProductPagination totalPages={10} />
    </div>
  );
}
```

**After:**
```typescript
import { getCategory, getCategoryPages, getProductsByCategory } from "../queries";
import { z } from "zod";

const paramsSchema = z.object({
  category: z.coerce.number(),
});

export const loader = async ({ params, request }: Route.LoaderArgs) => {
  const url = new URL(request.url);
  const page = url.searchParams.get("page") || 1;
  
  const { data, success } = paramsSchema.safeParse(params);
  if (!success) {
    throw new Response("Invalid category", { status: 400 });
  }

  const category = await getCategory(data.category);
  const products = await getProductsByCategory({
    categoryId: data.category,
    page: Number(page),
  });
  const totalPages = await getCategoryPages(data.category);

  return { category, products, totalPages };
};

export default function CategoryPage({ loaderData }: Route.ComponentProps) {
  return (
    <div>
      <Hero
        title={loaderData.category.name}
        subtitle={loaderData.category.description}
      />
      <div>
        {loaderData.products.map((product) => (
          <ProductCard
            key={product.product_id}
            id={product.product_id}
            name={product.name}
            description={product.description}
            reviewsCount={product.reviews}
            viewsCount={product.views}
            votesCount={product.upvotes}
          />
        ))}
      </div>
      <ProductPagination totalPages={loaderData.totalPages} />
    </div>
  );
}
```

**핵심 포인트:**
- **Zod 검증**: URL 파라미터를 `z.coerce.number()`로 숫자 변환 및 검증
- **병렬 로딩**: 카테고리 정보, 제품 목록, 페이지 수를 병렬로 조회 가능
- **동적 메타**: 카테고리 이름을 메타 태그에 포함
- **페이지네이션**: 카테고리별 제품 목록에 페이지네이션 적용

### 5. 타입 수정: ID 타입 일치

**변경된 파일: `app/features/products/components/category-card.tsx`**

```typescript
// Before
interface CategoryCardProps {
  id: string;
}

// After
interface CategoryCardProps {
  id: number; // category_id는 number 타입
}
```

**변경된 파일: `app/features/products/components/product-card.tsx`**

```typescript
// Before
interface ProductCardProps {
  id: string;
}

// After
interface ProductCardProps {
  id: number | string; // product_id는 number이지만 유연성 위해 union 타입
}
```

**변경된 파일: `app/common/pages/home-page.tsx`**

```typescript
// Before
id={product.product_id.toString()}

// After
id={product.product_id} // number 타입 그대로 사용
```

**핵심 포인트:**
- **타입 일치**: DB 타입과 TypeScript 타입 일치
- **불필요한 변환 제거**: `toString()` 제거로 성능 개선
- **유연성**: `number | string`으로 다양한 사용 케이스 지원

## 우리 프로젝트에 적용하기

### 현재 상태 분석

우리 프로젝트는 현재:
- ✅ Supabase 클라이언트 사용 중
- ✅ Loader 함수 사용 중
- ✅ Zod를 사용한 검증 패턴 적용 중
- ✅ 페이지네이션 구현됨
- ❌ 공통 select 쿼리 추출 미적용
- ❌ 카테고리 필터링 기능 미구현

### 적용 전략

#### 1단계: 공통 Select 쿼리 추출 패턴 이해

**기본 패턴:**
```typescript
const commonSelect = `
  field1,
  field2,
  field3:related_table->>field
`;

export const getItems = async () => {
  const { data, error } = await client
    .from("table_name")
    .select(commonSelect);
  // ...
};
```

**장점:**
- 중복 코드 제거
- 필드 변경 시 한 곳만 수정
- 일관성 보장

#### 2단계: 카테고리 필터링 패턴

**기본 패턴:**
```typescript
export const getItemsByCategory = async ({
  categoryId,
  page,
}: {
  categoryId: number;
  page: number;
}) => {
  const { data, error } = await client
    .from("items")
    .select(commonSelect)
    .eq("category_id", categoryId)
    .range((page - 1) * PAGE_SIZE, page * PAGE_SIZE - 1);
  
  if (error) throw error;
  return data;
};
```

#### 3단계: 타입 일치 패턴

**DB 타입 확인:**
- `category_id`: `bigint` → TypeScript `number`
- `product_id`: `bigint` → TypeScript `number`

**타입 정의:**
```typescript
interface Props {
  id: number; // DB 타입과 일치
}
```

## 공통 Select 쿼리 패턴

### 기본 패턴

```typescript
const itemListSelect = `
  item_id,
  name,
  description,
  metadata:stats->>field
`;

export const getItems = async () => {
  const { data, error } = await client
    .from("items")
    .select(itemListSelect);
  // ...
};
```

### JSONB 필드 추출

```typescript
const selectWithJsonb = `
  item_id,
  name,
  upvotes:stats->>upvotes,
  views:stats->>views,
  reviews:stats->>reviews
`;
```

### 재사용성

```typescript
// 여러 함수에서 동일한 select 사용
export const getItems = async () => {
  return client.from("items").select(itemListSelect);
};

export const getItemsByCategory = async (categoryId: number) => {
  return client
    .from("items")
    .select(itemListSelect)
    .eq("category_id", categoryId);
};
```

## 카테고리 필터링 패턴

### 기본 패턴

```typescript
export const getItemsByCategory = async ({
  categoryId,
  page = 1,
}: {
  categoryId: number;
  page?: number;
}) => {
  const { data, error } = await client
    .from("items")
    .select(commonSelect)
    .eq("category_id", categoryId)
    .range((page - 1) * PAGE_SIZE, page * PAGE_SIZE - 1);
  
  if (error) throw error;
  return data;
};
```

### 페이지 수 계산

```typescript
export const getCategoryPages = async (categoryId: number) => {
  const { count, error } = await client
    .from("items")
    .select(`item_id`, { count: "exact", head: true })
    .eq("category_id", categoryId);
  
  if (error) throw error;
  if (!count) return 1;
  return Math.ceil(count / PAGE_SIZE);
};
```

## 타입 일치 패턴

### DB 타입 확인

```typescript
// Schema 확인
category_id: bigint({ mode: "number" }) // → TypeScript: number
product_id: bigint({ mode: "number" })  // → TypeScript: number
```

### 컴포넌트 Props 타입

```typescript
// Before
interface Props {
  id: string; // 타입 불일치
}

// After
interface Props {
  id: number; // DB 타입과 일치
}
```

### 불필요한 변환 제거

```typescript
// Before
id={item.id.toString()} // 불필요한 변환

// After
id={item.id} // 타입 그대로 사용
```

## 장점

1. **공통 Select 쿼리**: 중복 제거, 유지보수성 향상
2. **카테고리 필터링**: 사용자가 원하는 카테고리만 조회
3. **타입 안전성**: DB 타입과 TypeScript 타입 일치
4. **성능**: 불필요한 타입 변환 제거

## 주의사항

1. **타입 일치**: DB 타입과 TypeScript 타입 확인 필수
2. **공통 Select**: 모든 쿼리에서 동일한 필드가 필요한지 확인
3. **성능**: 카테고리별 필터링 시 인덱스 확인 필요
4. **유연성**: 필요시 `number | string` 같은 union 타입 고려

## 다음 단계

1. ✅ 공통 Select 쿼리 패턴 이해
2. ✅ 카테고리 필터링 패턴 학습
3. ✅ 타입 일치 패턴 학습
4. ⏳ 카테고리 검색 기능 추가
5. ⏳ 카테고리 정렬 기능 추가
6. ⏳ 카테고리별 통계 기능 추가

## 참고 자료

- [Supabase 필터링 문서](https://supabase.com/docs/reference/javascript/filter)
- [Supabase JSONB 연산자](https://supabase.com/docs/reference/javascript/using-filters#jsonb-operators)
- [Zod coerce 문서](https://zod.dev/?id=coercion)

