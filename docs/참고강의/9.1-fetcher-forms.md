# 9.1 fetcher Forms

## 커밋 요약

`useFetcher`와 `fetcher.Form`을 사용하여 페이지 리로드 없이 Form을 제출하는 패턴을 구현한 커밋입니다. 별도의 Action 페이지로 분리, Hidden input 사용, 조건부 스타일링 등의 패턴을 보여줍니다.

## 주요 변경사항

### 1. useFetcher 사용

**구현**:
```typescript
import { useFetcher } from "react-router";

export default function PostPage({ loaderData, actionData }: Route.ComponentProps) {
  const fetcher = useFetcher();
  
  return (
    <fetcher.Form
      method="post"
      action={`/community/${loaderData.post.post_id}/upvote`}
    >
      <input
        type="hidden"
        name="postId"
        value={loaderData.post.post_id}
      />
      <Button variant="outline">
        <ChevronUpIcon className="size-4 shrink-0" />
        <span>{loaderData.post.upvotes}</span>
      </Button>
    </fetcher.Form>
  );
}
```

**패턴**:
- `useFetcher()` 훅 사용
- `fetcher.Form`으로 Form 생성
- `action` prop으로 별도 Action 페이지 지정
- Hidden input으로 데이터 전달

**장점**:
- 페이지 리로드 없이 제출
- 사용자 경험 개선
- 같은 페이지에 머물면서 상태 업데이트

### 2. 별도 Action 페이지로 분리

**구현**:
```typescript
// app/features/community/pages/upvote-post-page.tsx
export const action = async ({ request, params }: Route.ActionArgs) => {
  const formData = await request.formData();
  const postId = formData.get("postId");
  
  console.log(postId);
  
  return {
    ok: true,
  };
};
```

**패턴**:
- 별도 Action 페이지 생성
- 간단한 Action 함수만 구현
- `{ ok: true }` 반환

**장점**:
- Action 로직 분리
- 재사용 가능한 Action
- 코드 구조 명확화

### 3. Routes에 Action 경로 추가

**구현**:
```typescript
// app/routes.ts
route("/:postId/upvote", "features/community/pages/upvote-post-page.tsx"),
```

**패턴**: Action을 별도 경로로 분리

**장점**: RESTful한 URL 구조

### 4. Hidden Input으로 데이터 전달

**구현**:
```typescript
<input
  type="hidden"
  name="postId"
  value={loaderData.post.post_id}
/>
```

**패턴**: Hidden input으로 ID 전달

**장점**: URL에 노출되지 않고 데이터 전달

## 적용 방안

### ✅ 이미 적용된 패턴

1. **Hidden Input 사용**: 일부 Form에서 사용 중
2. **별도 Action 페이지**: 일부 기능에서 사용 중
3. **조건부 스타일링**: 일부 컴포넌트에서 사용 중

### 🔄 추가로 적용 가능한 패턴

#### 1. useFetcher를 사용한 Form 제출 (우선순위: 중간)

**현재 상태**: 대부분 일반 Form 사용

**적용 방안**:
```typescript
const fetcher = useFetcher();

<fetcher.Form
  method="post"
  action="/api/like"
>
  <input type="hidden" name="projectId" value={projectId} />
  <Button>좋아요</Button>
</fetcher.Form>
```

**적용 대상**:
- 좋아요/업보트 기능
- 북마크 기능
- 팔로우 기능
- 기타 상호작용 기능

**장점**:
- 페이지 리로드 없이 제출
- 사용자 경험 개선
- 빠른 피드백

#### 2. 별도 Action 페이지로 분리 (우선순위: 중간)

**현재 상태**: 일부 Action이 같은 페이지에 있음

**적용 방안**: 상호작용 기능을 별도 Action 페이지로 분리

**장점**:
- Action 로직 분리
- 재사용 가능
- 코드 구조 명확화

#### 3. fetcher.state로 로딩 상태 표시 (우선순위: 낮음)

**현재 상태**: 로딩 상태 표시 부족

**적용 방안**:
```typescript
const fetcher = useFetcher();
const isSubmitting = fetcher.state === "submitting";

<Button disabled={isSubmitting}>
  {isSubmitting ? "처리 중..." : "좋아요"}
</Button>
```

**장점**: 사용자에게 피드백 제공

## 구현 우선순위

### 중간 (점진적 적용)

1. **useFetcher를 사용한 Form 제출**
   - 영향도: 중간 (UX 개선)
   - 난이도: 낮음
   - 효과: 페이지 리로드 없이 제출

2. **별도 Action 페이지로 분리**
   - 영향도: 중간 (코드 구조 개선)
   - 난이도: 낮음
   - 효과: 코드 구조 명확화

### 낮음 (선택사항)

3. **fetcher.state로 로딩 상태 표시**
   - 영향도: 낮음 (UX 개선)
   - 난이도: 낮음
   - 효과: 사용자 피드백 개선

## 참고사항

- `useFetcher`는 페이지 리로드 없이 제출할 때 사용
- `fetcher.Form`은 일반 `Form`과 동일하게 사용 가능
- `action` prop으로 별도 Action 페이지 지정
- Hidden input으로 데이터 전달
- `fetcher.state`로 제출 상태 확인 가능 (`"idle"`, `"submitting"`, `"loading"`)
- `fetcher.data`로 Action 반환값 접근 가능
- 별도 Action 페이지는 간단한 Action 함수만 구현
- RESTful한 URL 구조 유지

